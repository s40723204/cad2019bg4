<!DOCTYPE html><html>
        <head>
        <title>cad2019bg4</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <link href="https://fonts.googleapis.com/css?family=Quicksand:300,400,500,700,900" rel="stylesheet">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/fonts/icomoon/style.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/bootstrap.min.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/magnific-popup.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/jquery-ui.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/owl.carousel.min.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/owl.theme.default.min.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/bootstrap-datepicker.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/fonts/flaticon/font/flaticon.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/aos.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/style.css">
        <link rel="shortcut icon" href="./../cmsimde/static/favicons.png">
        
        <style type='text/css'>
            .site-section {
            background-color: #FFFF;
            padding: 40px 40px;
            }
            body > div > div.dropdown.open {
                display: block;
            }
        </style>
    
        <!-- <script src="./../cmsimde/static/jquery.js"></script> -->
        <!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script> -->
        <script src="../cmsimde/static/chimper/js/jquery-3.3.1.min.js"></script>
        <link rel="stylesheet" href="./../cmsimde/static/tipuesearch/css/normalize.min.css">
        <script src="./../cmsimde/static/tipuesearch/tipuesearch_set.js"></script>
        <script src="tipuesearch_content.js"></script>
        <link rel="stylesheet" href="./../cmsimde/static/tipuesearch/css/tipuesearch.css">
        <script src="./../cmsimde/static/tipuesearch/tipuesearch.js"></script>
        <script>
            /* original tipuesearch
            $(document).ready(function() {
                 $('#tipue_search_input').tipuesearch();
            });
            */
            // customed doSearch
            function doSearch() {
                $('#tipue_search_input').tipuesearch({
                    newWindow: true, 
                    minimumLength: 2,
                    wholeWords: false, // for search 中文
                });
            }
            $(document).ready(doSearch);
        </script>
        
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shCore.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushJScript.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushJava.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushPython.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushSql.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushHaxe.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushXml.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushPhp.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushLua.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushCpp.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushCss.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushCSharp.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushDart.js"></script>
<link type="text/css" rel="stylesheet" href="./../cmsimde/static/syntaxhighlighter/css/shCoreDefault.css"/>
<script type="text/javascript">SyntaxHighlighter.all();</script>

<!-- 啟用 LaTeX equations 編輯 -->
<script src="https://scrum-3.github.io/web/math/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>
<script type="text/javascript">
init_mathjax = function() {
    if (window.MathJax) {
        // MathJax loaded
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
            },
            displayAlign: 'left', // Change this to 'center' to center equations.
            "HTML-CSS": {
                styles: {'.MathJax_Display': {"margin": 0}}
            }
        });
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
    }
}
init_mathjax();
</script>

<!-- 暫時不用
<script src="./../cmsimde/static/fengari-web.js"></script>
<script type="text/javascript" src="./../cmsimde/static/Cango-13v08-min.js"></script>
<script type="text/javascript" src="./../cmsimde/static/CangoAxes-4v01-min.js"></script>
<script type="text/javascript" src="./../cmsimde/static/gearUtils-05.js"></script>
-->
<!-- for Brython 暫時不用
<script src="https://scrum-3.github.io/web/brython/brython.js"></script>
<script src="https://scrum-3.github.io/web/brython/brython_stdlib.js"></script>
-->
<style>
img.add_border {
    border: 3px solid blue;
}
</style>

</head>
<body>
<div class='container'><nav>
        
    <div class="site-wrap">

    <div class="site-mobile-menu">
      <div class="site-mobile-menu-header">
        <div class="site-mobile-menu-close mt-3">
          <span class="icon-close2 js-menu-toggle"></span>
        </div>
      </div>
      <div class="site-mobile-menu-body"></div>
    </div>
    
            <header class="site-navbar py-4 bg-white" role="banner">
              <div class="container-fluid">
                <div class="row align-items-center">
                <h1>cad2019bg4</h1>
                <div class="pl-4">
                    <form>
                    <input type="text" placeholder="Search" name="q" id="tipue_search_input" pattern=".{2,}" title="At least 2 characters" required>
                    </form>
                </div>
                  <!-- <div class="col-11 col-xl-2">
                    <h1 class="mb-0 site-logo"><a href="index.html" class="text-black h2 mb-0">cad2019bg4</a></h1> 
                  </div>
                  -->
                  <div class="col-12 col-md-10 d-none d-xl-block">
                    <nav class="site-navigation position-relative text-right" role="navigation">
    <ul class='site-menu js-clone-nav mr-auto d-none d-lg-block'>
                        <li class="active has-children"><a href="index.html">Home</a>
                        <ul class="dropdown">
                            <li><a href="sitemap.html">Site Map</a></li>
                            <li><a href="./../reveal/index.html">reveal</a></li>
                            <li><a href="./../blog/index.html">blog</a></li>
                        </ul>
                      </li>
                     <li><a href='Member.html'>Member</a><li class='has-children'><a href='Week.html'>Week</a><ul class='dropdown'><li class='has-children'><a href='week10 - 14.html'>week10 - 14</a><ul class='dropdown'><li><a href='week10.html'>week10</a><li><a href='SolidWorks-2.html'>SolidWorks-2</a><li><a href='NX.html'>NX</a><li><a href='Creo Parametric.html'>Creo Parametric</a><li><a href='SDRC.html'>SDRC</a><li><a href='week12.html'>week12</a><li><a href='week13.html'>week13</a></li></ul><li class='has-children'><a href='week15 - 18.html'>week15 - 18</a><ul class='dropdown'><li><a href='week17協同任務.html'>week17協同任務</a></li></li></ul></ul><li><a href='M.A.L.html'>M.A.L</a><li class='has-children'><a href='NOTE.html'>NOTE</a><ul class='dropdown'><li class='has-children'><a href='website.html'>website</a><ul class='dropdown'><li><a href='Batch Command.html'>Batch Command</a></li>
                      </ul>
                </nav>
              </div>
              <div class="d-inline-block d-xl-none ml-md-0 mr-auto py-3" style="position: relative; top: 3px;"><a href="#" class="site-menu-toggle js-menu-toggle text-black"><span class="icon-menu h3"></span></a></div>
              </div>

            </div>
          </div>
          
        </header>
    <div id="tipue_search_content">week15 - 18 << <a href='week15 - 18.html'>Previous</a> <a href='M.A.L.html'>Next</a> >> M.A.L<br /><h1>week17協同任務</h1>
<h4>Building a clean model tutorial</h4>
<p>40723201          吳沛汶</p>
<p></p>
<hr/>
<p>40723204          邱倚瀅</p>
<p>The second important step is to export the original data with a limited precision: most CAD applications let you specify the level of details of exported meshes. It might also be important to export the objects in several steps, when the drawing consists of large and small objects; this is to avoid having large objects too precisely defined (too many triangles) and small objects too roughly defined (too few triangles): simply export large objects first (by adjusting the desired precision settings), then small objects (by adjusting up precision settings).</p>
<p>第二個重要步驟是以有限的精度導出原始數據：大多數CAD應用程式都允許指定導出的網格的細節級別。當工程圖由大小項目組成時，分幾步導出也很重要。這是為了避免大項目定義太精確（三角形太多）和小項目定義太粗糙（三角形太少）：首先簡單地導出大項目（通過調整所需的精度設置），然後導出小項目（通過調整精度設置） 。</p>
<p> CoppeliaSim supports currently following CAD data formats: <a href="http://www.coppeliarobotics.com/helpFiles/en/importExport.htm">OBJ</a>, <a href="http://www.coppeliarobotics.com/helpFiles/en/importExport.htm">STL</a>, <a href="http://www.coppeliarobotics.com/helpFiles/en/importExport.htm">DXF</a>, <a href="http://www.coppeliarobotics.com/helpFiles/en/importExport.htm">3DS</a> (Windows only), and <a href="http://www.coppeliarobotics.com/helpFiles/en/colladaPlugin.htm">Collada</a>. <a href="http://www.coppeliarobotics.com/helpFiles/en/urdfPlugin.htm">URDF</a> is also supported, but not mentionned here since it is not a pure mesh-based file format.</p>
<p>CoppeliaSim目前支援以下CAD格式：OBJ，STL，DXF，3DS（僅Windows）和Collada。另外還支援URDF，但此處未提及，因為它不是純網格的文件格式</p>
<p>Now suppose that we have applied all possible simplifications as described in previous section. We might still end-up with a too heavy mesh after import:</p>
<p>現在，假設我們已按照上一節中所述應用了所有可能的簡化。導入後，我們可能最終仍然會留下一個過重的網格：</p>
<p> You can notice that the whole robot was imported as a single mesh. We will see later how to divide it appropriately. Notice also the wrong orientation of the imported mesh: best is to keep the orientation as it is, until the whole model was built, since, if at a later stage we want to import other items that are related to that same robot, they will automatically have the correct position/orientation relative to the original mesh.</p>
<p>這裡會注意到整個機器人是作為單個網格導入的。稍後將看到如何對此機器人進行適當劃分。要注意導入的網格的方向是否錯誤：最好保持其方向不變，直到建完整個模型為止，因為如果在後面的階段中要導入與此機器人相關的其他項目，它們將自動具有相對於原始網格的正確位置/方向。</p>
<p> At this stage, we have several functions at our disposal, to simplify the mesh:</p>
<p>在此階段，可以使用多種功能來簡化網格：</p>
<p><strong>Automatic mesh division:</strong>allows to generate a new shape for all elements that are not linked together via a common edge. This does not always work for the selected mesh, but is always worth a try, since working on mesh elements gives us more control than if we had to work on all elements at the same time. The function can be accessed with [Menu bar --&gt; Edit --&gt; Grouping/Merging --&gt; Divide selected shapes]. Sometimes, a mesh will be divided more than expected. In that case, simply merge elements that logically belong together (i.e. that will have the same visual attributes and that are part of the same link) back into one single shape ([Menu bar --&gt; Edit -&gt; Grouping/Merging --&gt; Merge selected shapes]).</p>
<p>自動網格劃分：允許為未通過公共邊鏈接在一起的所有元素生成新形狀。這並不總是適用於選定的網格，但是總是值得一試的，因為與必須同時處理所有元素相比，處理網格元素可以為我們提供更多的控制權。可以通過[菜單欄-&gt;編輯-&gt;分組/合併-&gt;分割所選形狀]訪問該功能。有時，網格劃分會超出預期。在這種情況下，只需將邏輯上屬於一起的元素（即，具有相同的視覺屬性並且屬於同一鏈接的一部分）合併回一個單一形狀（[菜單欄-&gt;編輯-&gt;分組/合併-&gt;合併選定的形狀]）。</p>
<p> <strong>Extract the convex hull:</strong>allows to simplify the mesh by transforming it into a convex hull. The function can be accessed with [Menu bar --&gt; Edit --&gt; Morph selection into convex shapes].</p>
<p>提取凸包：通過將其轉換為凸包來簡化網格。可以通過[菜單欄-&gt;編輯-&gt;將選擇變形為凸形]來訪問該功能</p>
<p> <strong>Decimate the mesh:</strong>allows to reduce the number of triangles contained in the mesh. The function can be accessed with [Menu bar --&gt; Edit --&gt; Decimate selected shape...].</p>
<p>抽取網格：減少網格中包含的三角形數量。可以通過[菜單欄-&gt;編輯-&gt;縮小所選形狀...]訪問該功能。</p>
<p> <strong>Remove the inside of the mesh:</strong>allows to simplify the mesh by removing its inside. This function is based on <span><a href="http://www.coppeliarobotics.com/helpFiles/en/visionSensors.htm">vision sensors</a></span> and might give more or less satisfying results depending on the selected settings. The function can be accessed with [Menu bar --&gt; Edit --&gt; Extract inside of selected shape].</p>
<p>刪除網格的內部：允許通過刪除其內部來簡化網格。此功能基於視覺傳感器，根據所選設置可能會或多或少地令人滿意。可以通過[菜單欄-&gt;編輯-&gt;提取選定形狀的內部]訪問該功能。</p>
<p>There is no predefined order in which above functions can/should be applied (except for the first item in the list, which should always be tried first), it heavily depends on the geometry of the mesh we are trying to simplify. Following image illustrates above functions applied to the imported mesh (let's suppose the first item in the list didn't work for us):</p>
<p>此處沒有可以應用上述功能的預定義順序（列表中的第一項除外，應始終首先嘗試該項），它在很大程度上取決於我們要簡化的網格的幾何形狀。下圖說明了應用於導入的網格的上述功能（假設列表中的第一項對我們不起作用）：</p>
<p> Notice how the convex hull doesn't help us at this stage. We decide to use the mesh decimation function first, and run the function twice in order to divide the number of triangles by a total of 50. Once that is done, we extract the inside of the simplified shape and discard it. We end-up with a mesh containing a total of 2'660 triangles (the original imported mesh contained more than 136'000 triangles!). The number of triangles/vertices a shape contains can be seen in the <a href="http://www.coppeliarobotics.com/helpFiles/en/geometryDialog.htm">shape geometry dialog</a>. 2'660 triangles are extremely few triangles for a whole robot model, and the visual appearance might suffer a little bit from it.</p>
<p>請注意，凸包在現階段如何對我們沒有幫助。我們決定首先使用網格抽取功能，然後運行兩次該功能，以將三角形的數量總共除以50。完成後，我們提取簡化形狀的內部並將其丟棄。我們最終得到的網格總共包含2'660個三角形（原始導入的網格包含了136'000個三角形！）。形狀包含的三角形/頂點的數量可以在形狀幾何對話框中看到。對於整個機器人模型，2'660三角形是極少的三角形，因此視覺外觀可能會因此受到影響。</p>
<hr/>
<p> </p>
<p>40723213          杜玗宸</p>
<p><strong><span>翻譯</span>Building a clean model tutorial</strong></p>
<p><span>At this stage we can start to divide the robot into separate links (remember, we</span></p>
<p><span>currently have only a single shape for the whole robot). You can do this in two different ways:</span></p>
<p>在這一階段，我們可以開始將機器人劃分為單獨的鏈接（請記住，</p>
<p>目前整個機器人只有一個形狀）。 您可以通過兩種不同的方式執行此操作：</p>
<ul>
<li><strong>Automatic mesh division:</strong>this function, which was already described in previous section, will inspect the shape and generate a new shape for all elements that are not linked together via a common edge. This does not always work, but is always worth a try. The function can be accessed with [Menu bar --&gt; Edit --&gt; Grouping/merging --&gt; Divide selected shapes].</li>
<li>自動網格劃分：上一小節已經描述了此功能，它將檢查形狀並為未通過公共邊鏈接在一起的所有元素生成新形狀。 這並不總是有效，但總是值得嘗試的。 可以通過<span>[</span>菜單欄<span>-&gt;</span>編輯<span>-&gt;</span>分組<span>/</span>合併<span>-&gt;</span>分割所選形狀<span>]</span>訪問該功能。</li>
<li><strong>Manual mesh division:</strong>via the the <span><a href="http://www.coppeliarobotics.com/helpFiles/en/triangleEditMode.htm">triangle edit mode</a></span>, you can manually select the triangles than logically belong together, then click <strong>Extract shape</strong>. This will generate a new shape in the scene. Delete the selected triangles after that operation.</li>
<li>手動網格劃分：通過三角形編輯模式，您可以手動選擇邏輯上不屬於邏輯的三角形，然後單擊“提取形狀”。 這將在場景中生成新形狀。 完成該操作後，刪除選定的三角形。</li>
</ul>
<p>In the case of our mesh, method 1 worked fine:</p>
<p><span>對於我們的網格，方法1可以正常工作：</span></p>
<p><img alt="" height="312" src="http://www.coppeliarobotics.com/helpFiles/en/images/modelTut5.jpg" width="640"/></p>
<p>[Divided mesh]</p>
<p></p>
<p>Now, we could further refine/simplify individual shapes. Sometimes also, a shape might look better if its convex hull is used instead. Othertimes, you will have to use several of above's described techniques iteratively, in order to obtain the desired result. Take for instance following mesh:</p>
<p>現在，我們可以進一步細化/簡化單個形狀。 有時，如果改用凸包，形狀可能會看起來更好。 有時，您將不得不反複使用上述幾種技術，以獲得所需的結果。 以以下網格為例：</p>
<p><img alt="" height="300" src="http://www.coppeliarobotics.com/helpFiles/en/images/modelTut6.jpg" width="151"/></p>
<p>[Imported mesh]</p>
<p></p>
<p>The problem with above's shape is that we cannot simplify it nicely, because of the holes it contains. So we have to go the more complicated way via the <span><a href="http://www.coppeliarobotics.com/helpFiles/en/shapeEditModes.htm">shape edit mode</a></span>, where we can extract individual elements that logically belong to the same convex sub-entity. This process can take several iterations: we first extract 3 approximate convex elements. For now, we ignore the triangles that are part of the two holes. While editing a shape in the shape edit mode, it can be convenient to switch the <span><a href="http://www.coppeliarobotics.com/helpFiles/en/layerSelectionDialog.htm">visibility layers</a></span>, in order to see what is covered by other scene items.</p>
<p>上面形狀的問題是，由於其中包含孔，我們無法很好地簡化它。 因此，我們必須通過形狀編輯模式進行更複雜的處理，在該模式下，我們可以提取邏輯上屬於同一凸形子實體的單個元素。 此過程可能需要進行多次迭代：我們首先提取3個近似凸元素。 現在，我們忽略作為兩個孔的一部分的三角形。 在形狀編輯模式下編輯形狀時，可以方便地切換可見性圖層，以查看其他場景項所覆蓋的內容。</p>
<p><img alt="" height="303" src="http://www.coppeliarobotics.com/helpFiles/en/images/modelTut7.jpg" width="640"/></p>
<p>[Step 1]</p>
<p></p>
<p>We end up with a toal of three shapes, but two of them will need further improvement. Now we can erase the triangles that are part of the holes. Finally, we extract the convex hull individually for the 3 shapes, then merge them back together with [Menu bar --&gt; Edit --&gt; Grouping/Merging --&gt; merge selected shapes]:</p>
<p>我們最終得到三個形狀的總和，但是其中兩個將需要進一步改進。 現在我們可以擦除作為孔的一部分的三角形。 最後，我們分別提取3種形狀的凸包，然後將其與[菜單欄-&gt;編輯-&gt;分組/合併-&gt;合併所選形狀]合併在一起：</p>
<p> <img alt="" height="303" src="http://www.coppeliarobotics.com/helpFiles/en/images/modelTut7.jpg" width="640"/></p>
<p>[Step 2]</p>
<p></p>
<p>In CoppeliaSim, we can enable/disable edge display for each shape. We can also specify an angle that will be taken into account for the edge display. A similar parameter is the <strong>shading angle</strong>, that dictates how facetted the shape will display. Those parameters, and a few others such as the shape <strong>color</strong>, can be adjusted in the <span><a href="http://www.coppeliarobotics.com/helpFiles/en/simulationPropertiesDialog.htm">shape properties</a></span>. Remember that <span><a href="http://www.coppeliarobotics.com/helpFiles/en/shapes.htm">shapes come in various flavours</a></span>. In this tutorial we have only dealt with simple shapes up to now: a simple shape has a single set of visual attributes (i.e. one color, one shading angle, etc.). If you merge two shapes, then the result will be a simple shape. You can also group shapes, in which case, each shape will retain its visual attributes.</p>
<p>In next step, we can merge elements that logically belong together (if they are part of the same rigid element, and if they have the same visual attributes). Then we change the visual attributes of the various elements. The easiest ist to adjust a few shapes that have different colors and visual attributes, and if we name the color with a specific string, we can later easily programmatically change that color, also if the shape is part of a compound shape. Then, we select all the shapes that have the same visual attributes, then control-select the shape that was already adjusted, then click <strong>Apply to selection</strong>, once for the <strong>Colors</strong>, once for the <strong>other properties</strong>, in the <span><a href="http://www.coppeliarobotics.com/helpFiles/en/shapeProperties.htm">shape properties</a></span>: this transfers all visual attributes to the selected shapes (including the color name if you provided one). </p>
<p>在CoppeliaSim中，我們可以啟用/禁用每種形狀的邊緣顯示。我們還可以指定邊緣顯示時要考慮的角度。相似的參數是陰影角，它指示形狀將在多方面顯示。這些參數以及其他一些參數（例如形狀顏色）可以在形狀屬性中進行調整。請記住，形狀有多種風味。到目前為止，在本教程中，我們僅處理簡單的形狀：簡單的形狀具有一組視覺屬性（即一種顏色，一個陰影角度等）。如果合併兩個形狀，則結果將是一個簡單的形狀。您還可以對形狀進行分組，在這種情況下，每個形狀將保留其視覺屬性。</p>
<p>在下一步中，我們可以合併邏輯上屬於一起的元素（如果它們屬於同一剛性元素，並且具有相同的視覺屬性）。然後，我們更改各種元素的視覺屬性。調整具有不同顏色和視覺屬性的幾種形狀的最簡便方法，如果我們使用特定的字符串來命名顏色，則以後可以輕鬆地以編程方式更改該顏色，即使該形狀是複合形狀的一部分。然後，我們選擇所有具有相同視覺屬性的形狀，然後控制選擇已調整的形狀，然後單擊“應用於選擇”，一次是“顏色”，一次是其他屬性，在形狀屬性中：這將轉移所有所選形狀的視覺屬性（如果提供的話，還包括顏色名稱）。</p>
<hr/>
<p>40723215          杜彥霆</p>
<p></p>
<hr/>
<p>40723218          林志豪</p>
<p></p>
<hr/>
<p>40723219          林承治</p>
<p></p>
<hr/>
<p>40723237          黃俊翔</p>
<ul>
<li><strong>respondable or non-respondable</strong>: a respondable shape will cause a collision reaction with other respondable shapes. They (and/or) their collider, will be influenced in their movement if they are dynamic. On the other hand, non-respondable shapes will not compute a collision response if they collide with other shapes.</li>
</ul>
<p> </p>
<ul>
<li><strong>可回應或不可回應</strong>：回應形狀會導致與其他可回應形狀發生碰撞反應。它們（和/或）碰撞器，如果他們是動態的，就會影響它們的運動。另一方面，如果不可回應的形狀與其他形狀碰撞，則它們不會計算碰撞回應。</li>
</ul>
<p>Above two points are illustrated <a href="http://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#staticAndRespondable">here</a>. Respondable shapes should be as simple as possible, in order to allow for a fast and stable simulation. A physics engine will be able to simulate following 5 types of shapes with various degrees of speed and stability:</p>
<p> </p>
<p>上圖所示。回應形狀應盡可能簡單，以便快速、穩定地模擬。物理引擎將能夠類比以下 5 種具有不同速度和穩定性的形狀：</p>
<ul>
<li><span><a href="http://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#pureShapes"><strong>Pure shapes</strong></a></span><strong>:</strong>a pure shape will be stable and handled very efficiently by the physics engine. The draw-back is that pure shapes are limited in geometry: mostly cuboids, cylinders and spheres. If possible, use those for items that are in contact with other items for a longer time (e.g. the feet of a humanoid robot, the base of a serial manipulator, the fingers of a gripper, etc.). Pure shapes can be created with [Menu bar --&gt; Add --&gt; Primitive shape].</li>
</ul>
<p> </p>
<ul>
<li><span><a href="http://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#pureShapes"><strong><span>純形狀</span></strong></a></span><strong>：</strong>純形狀將穩定，物理引擎處理效率很高。回拉是純形狀在幾何中是有限的：主要是立方體、圓柱體和球體。如果可能，將這些物品用於與其他物品接觸更長時間的物品（例如類人機器人的腳、串列操縱器的底座、夾持器的手指等）。可以使用 [功能表列 -- &gt; 添加 -gt; 原始形狀]創建純形狀。</li>
</ul>
<p> </p>
<ul>
<li><span><a href="http://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#pureShapes"><strong>Pure compound shapes</strong></a></span><strong>:</strong>a pure compound shape is a grouping of several pure shapes. It performs almost as well as pure shapes and shares similar properties. Pure compound shapes can be generated by grouping several pure shapes [Menu bar --&gt; Edit --&gt; Grouping/Merging --&gt; Group selected shapes].</li>
</ul>
<p> </p>
<ul>
<li><span><a href="http://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#pureShapes"><strong><span>純複合形狀</span></strong></a></span><strong>：</strong>純複合形狀是幾個純形狀的組合。它的性能幾乎與純形狀相同，並且具有相似的屬性。純複合形狀可以通過分組多個純形狀生成 <span>[</span>功能表條 -- &gt; 編輯 --&gt; 分組/合併 -- &gt; 組選定形狀]。</li>
</ul>
<p> </p>
<ul>
<li><span><a href="http://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#convexShapes"><strong>Convex shapes</strong></a></span>: a convex shape will be a little bit less stable and take a little bit more computation time when handled by the physics engine. It allows for a more general geometry (only requirement: it need to be convex) than pure shapes. If possible, use convex shapes for items that are sporadically in contact with other items (e.g. the various links of a robot). Convex shapes can be generated with [Menu bar --&gt; Add --&gt; Convex hull of selection] or with [Menu bar --&gt; Edit --&gt; Morph selection into convex shapes].</li>
</ul>
<p> </p>
<ul>
<li><span><a href="http://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#convexShapes"><strong><span>凸形形狀</span></strong></a></span>：當物理引擎處理時，凸形狀會稍微不穩定一點，並且需要多一點的計算時間。它允許更一般的幾何形狀（僅要求：它需要凸）而不是純形狀。如果可能，對偶爾與其他專案接觸的專案（例如機器人的各種連結）使用凸形形狀。可以使用 [功能表列 -- &gt; 添加 --gt; 選擇的凸包]或使用 [功能表列 -- &gt; 編輯 --&gt; 將選擇轉換為凸形形狀]生成凸形形狀。</li>
</ul>
<p> </p>
<ul>
<li><span><a href="http://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#convexShapes"><strong>Compound convex shapes, or convex decomposed shapes</strong></a></span>: a convex decomposed shape is a grouping of several convex shapes. It performs almost as well as convex shapes and shares similar properties. Convex decomposed shapes can be generated by grouping several convex shapes [Menu bar --&gt; Edit --&gt; Grouping/Merging --&gt; Group selected shapes], with [Menu bar --&gt; Add --&gt; Convex decomposition of selection...], or with [Menu bar --&gt; Edit --&gt; Morph selection into its convex decomposition...].</li>
</ul>
<p> </p>
<ul>
<li><span><a href="http://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#convexShapes"><strong><span>複合凸形或凸分解形狀</span></strong></a></span>：凸分解形狀是多個凸形形狀的分組。它的性能幾乎與凸形狀一樣好，並且具有類似的屬性。可以通過對多個凸形形狀進行分組[功能表條 --&gt; 編輯 -- &gt; 分組/合併 -- &gt; 組選定形狀]生成，使用 [功能表列 -- &gt; 添加 --&gt; 選擇的凸分解...]，或者使用 [功能表列 -- &gt; 編輯 -- &gt; 變形選擇到其凸分解中...]。</li>
</ul>
<p> </p>
<ul>
<li><strong>Random shapes</strong>: a random shape is a shape that is not convex nor pure. It generally has poor performance (calculation speed and stability). Avoid using random shapes as much as possible.</li>
</ul>
<p> </p>
<ul>
<li><strong>隨機形狀</strong>：隨機形狀是不凸或純的形狀。它的性能通常較差（計算速度和穩定性）。儘量避免使用隨機形狀。</li>
</ul>
<p> </p>
<p>So the order of preference would be: pure shapes, pure compound shapes, convex shapes, compound convex shapes, and finally random shapes. Make sure to also read <a href="http://www.coppeliarobotics.com/helpFiles/en/shapes.htm">this page</a>. In case of the robot we want to build, we will make the base of the robot as a pure cylinder, and the other links as convex or convex decomposed shapes.</p>
<p> </p>
<p>因此，偏好的順序是：純形狀、純複合形狀、凸形、複合凸形狀，最後是隨機形狀。請務必也閱讀<a href="http://www.coppeliarobotics.com/helpFiles/en/shapes.htm"><span>此頁面</span></a>。在我們想要構建的機器人的情況下，我們將機器人的底座作為一個純圓柱體，其他連結作為凸或凸分解的形狀。</p>
<p> </p>
<p>We could use the dynamically enabled shapes also as the visible parts of the robot, but that would probably not look good enough. So instead, we will build for each visible shape we have created in <a href="http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm#visibleShapes">the first part of the tutorial</a> a dynamically enabled counterpart, which we will keep hidden: the hidden part will represent the dynamic model and be exclusively used by the physics engine, while the visible part will be used for visualization, but also for <a href="http://www.coppeliarobotics.com/helpFiles/en/distanceCalculation.htm">minimum distance calculations</a>, <a href="http://www.coppeliarobotics.com/helpFiles/en/proximitySensors.htm">proximity sensor detections</a>, etc.</p>
<p> </p>
<p>我們可以將動態啟用的形狀用作機器人的可見部分，但可能看起來不夠好。因此，我們將為在<a href="http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm#visibleShapes"><span>本教程的第一部分</span></a>中創建的每個可見形狀構建一個動態啟用的對應形狀，我們將隱藏該形狀：隱藏部分將表示動態模型，並由物理引擎獨佔使用，而可見部分將用於視覺化，但也用於<a href="http://www.coppeliarobotics.com/helpFiles/en/distanceCalculation.htm"><span>最小距離計算</span></a>、<a href="http://www.coppeliarobotics.com/helpFiles/en/proximitySensors.htm"><span>接近感應器檢測</span></a>等。</p>
<p>We select object <em>robot</em>, copy-and-paste it into a new scene (in order to keep the original model intact) and start the <a href="http://www.coppeliarobotics.com/helpFiles/en/triangleEditMode.htm">triangle edit mode</a>. If object <em>robot</em> was a compound shape, we would first have had to ungroup it ([Menu bar --&gt; Edit --&gt; Grouping/Merging --&gt; Ungroup selected shapes]) then merge the individual shapes ([Menu bar --&gt; Edit --&gt; Grouping/Merging --&gt; Merge selected shapes]) before being able to start the triangle edit mode. Now we select the few triangles that represent the power cable, and erase them. Then we select all triangles in that shape, and click Extract cylinder. We can now leave the edit mode and we have our base object represented as a pure cylinder:</p>
<p> </p>
<p>我們選擇物件<em>機器人</em>，複製並粘貼到一個新的場景（為了保持原始模型不變），並開始<a href="http://www.coppeliarobotics.com/helpFiles/en/triangleEditMode.htm"><span>三角形編輯模式</span></a>。如果物件<em>機器人</em>是複合形狀，我們首先必須取消群組它（[功能表列 -- &gt; 編輯 --&gt; 分組/合併 -- &gt; 取消組選定形狀]），然後合併單個形狀（[功能表列 -- &gt; 編輯 --&gt; 分組/合併 -- &gt; 合併所選形狀]），然後才能啟動三角形編輯模式。現在，我們選擇表示電源線的幾個三角形，並擦除它們。然後，我們選擇該形狀中的所有三角形，然後按一下"提取圓柱體"。我們現在可以離開編輯模式，並將基本物件表示為純圓柱體：</p>
<p>We rename the new shape (with a double-click on its name in the <a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy">scene hierarchy</a>) as <em>robot_dyn</em>, assign it to visibility layer 9, then copy it to the original scene. The rest of the links will be modelled as convex shapes, or compound convex shapes. We now select the first mobile link (i.e. object <em>robot_link1</em>) and generate a convex shape from it with [Menu bar --&gt; Add --&gt; Convex hull of selection].</p>
<p>我們將新形狀（在<a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy"><span>場景層次結構</span></a>中按兩下其名稱）重命名為<em>robot_dyn，</em>將其分配給可見度層 9，然後將其複製到原始場景。其餘連結將建模為凸形或複合凸形。現在，我們選擇第一個手機連結（即物件<em>robot_link1），</em>並生成一個凸形形狀，從它與 [功能表列 -- &gt; 添加 -&gt; 凸面選擇包]。</p>
<hr/>
<p><span>40723242          趙子德</span></p>
<p><strong>Model definition:</strong></p>
<p>原文:</p>
<p>Now we are ready to define our model. We start by building the model herarchy: we attach the last dynamic robot link (<em>robot_link_dyn6</em>) to its corresponding joint (<em>robot_joint6</em>) by selecting <em>robot_link_dyn6</em>, then control-selecting <em>robot_joint6</em>, then [Menu bar --&gt; Edit --&gt; Make last selected object parent]. We could also have done this step by simply dragging object <em>robot_link_dyn6</em> onto <em>robot_link6</em> in the <a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy">scene hierarchy</a>. We go on by now attaching <em>robot_joint6</em> to <em>robot_link_dyn5</em>, and so on, until arrived at the base of the robot. We now have following scene hierarchy:</p>
<p>中譯:</p>
<p>現在我們準備定義模型了。 我們從建立模型層次結構開始：通過選擇robot_link_dyn6，然後控制選擇robot_joint6，然後選擇[菜單欄-&gt;編輯-&gt;使最後一個選中的對象，將最後一個動態機器人鏈接（robot_link_dyn6）附加到其相應的關節（robot_joint6）。 我們還可以通過簡單地將對象robot_link_dyn6拖到場景層次結構中的robot_link6上來完成此步驟。 現在，我們將robot_joint6附加到robot_link_dyn5上，依此類推，直到到達機器人的底部。 現在，我們具有以下場景層次結構：</p>
<p>原文:</p>
<p>It is nice and more logical to have a simple name for the model base, since the model base will also represent the model itself. So we rename <em>robot</em> to <em>robot_visibleBase</em>, and <em>robot_dyn</em> to <em>robot</em>. Now we select the base of the hierarchy tree (i.e. object <em>robot</em>) and in the <a href="http://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm">object common properties</a> we enable <strong>Object is model base</strong>. We also enable <strong>Object/model can transfer or accept DNA</strong>. A model bounding box appeared, encompassing the whole robot. The bounding box however appears to be too large: this is because the bounding box also encompasses the invisible items, such as the joints. We now exclude the joints from the model bounding box by enabling the <strong>Don't show as inside model selection</strong> item for all joints. We could do the same procedure for all invisible items in our model. This is also a useful option in order to also exclude large sensors or other items from the model bounding box. We now have following situation:</p>
<p>中譯:</p>
<p>為模型庫起一個簡單的名字是很好而且更合乎邏輯的，因為模型庫也將代表模型本身。 因此，我們將robot重命名為robot_visibleBase，並將robot_dyn重命名為robot。 現在我們選擇層次結構樹的基礎（即對像機械手臂），並在對象公共屬性中啟用<span class="mjx-chtml MathJax_CHTML" data-mathml='&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mo&gt;&lt;/mo&gt;&lt;/mstyle&gt;&lt;/math&gt;' id="MathJax-Element-1-Frame" role="presentation" style="box-sizing: border-box; display: inline-block; line-height: 0; text-indent: 0px; text-align: left; text-transform: none; font-style: normal; font-weight: normal; font-size: 18.08px; letter-spacing: normal; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; margin: 0px; padding: 1px 0px; position: relative;" tabindex="0"><span aria-hidden="true" class="mjx-math" id="MJXc-Node-1"><span class="mjx-mrow" id="MJXc-Node-2"><span class="mjx-mstyle" id="MJXc-Node-3"><span class="mjx-mrow" id="MJXc-Node-4"><span class="mjx-mo" id="MJXc-Node-5"></span></span></span></span></span><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo></mo></mstyle></math></span></span>對像是模型基礎''。 我們還使對象/模型可以轉移或接受DNA。 出現了一個模型包圍盒，包圍了整個機器人。 但是，邊界框似乎太大：這是因為邊界框還包含不可見的項，例如關節。 現在，通過對所有關節啟用“不顯示為內部模型”選擇項，將關節從模型邊界框中排除。 我們可以對模型中的所有不可見項執行相同的過程。 這也是一個有用的選項，可以將大型傳感器或其他項目也排除在模型邊界框之外。 我們現在有以下情況：</p>
<p>原文:</p>
<p>We now protect our model from accidental modification. We select all visible objects in the robot, then enable <strong>Select base of model instead</strong>: if we now click a visible link in the scene, the base of the robot will be selected instead. This allows us to manipulate the model as if it was a single object. We can still select visible objects in the robot via control-shift-clicking in the scene, or by selecting the object in the scene hierarchy. We now put the robot into a correct default position/orientation. First, we save current scene as a reference (e.g. if at a later stage we need to import CAD data that have the same orientation at the curent robot). Then we select the model and <a href="http://www.coppeliarobotics.com/helpFiles/en/coordinateDialog.htm">modify its position/orientation</a> appropriately. It is considered good practice to position the model (i.e. its base object) at X=0 and Y=0.</p>
<p>中譯:</p>
<p>現在，我們保護模型免受意外修改。 我們選擇機器人中的所有可見對象，然後啟用“選擇模型的基礎”：如果現在單擊場景中的可見鏈接，則會改為選擇機器人的基礎。 這使我們可以像對待單個對像一樣操作模型。 我們仍然可以通過按住Shift鍵並單擊場景或在場景層次中選擇對象來選擇機器人中的可見對象。 現在，我們將機器人置於正確的默認位置/方向。 首先，我們將當前場景保存為參考（例如，如果稍後需要在當前機器人上導入方向相同的CAD數據）。 然後，我們選擇模型並適當修改其位置/方向。 將模型（即其基礎對象）定位在X = 0和Y = 0處被認為是一種好習慣。</p>
<p>原文:</p>
<p>We now run the simulation: the robot will collapse, since the joints are not controlled by default. <a href="http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm#joints">When we added the joints in the previous stage</a>, we created joints in force/torque mode, but their motor or controller was disabled (by default). We can now adjust our joints to our requirements. In our case, we want a simple PID controller for each one of them. In the joint dynamic properties, we click <strong>Motor enabled</strong> and adjust the <strong>maximum torque</strong>. We then click <strong>Control loop enabled</strong> and select <strong>Position control (PID)</strong>. We now run the simulation again: the robot should hold its position. Try to switch the current physics engine to see if the behaviour is consistent across all supported physics engines. You can do this via the appropriate <a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars">toolbar button</a>, or in the <a href="http://www.coppeliarobotics.com/helpFiles/en/dynamicsDialog.htm">general dynamics properties</a>.</p>
<p>During simulation, we now verify the scene dynamic content via the <a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars">Dynamic content visualization &amp; verification toolbar button</a>. Now, only items that are taken into account by the physics engine will be display, and the display is <a href="http://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#dynamicContentVisualization">color-coded</a>.</p>
<p>中譯:</p>
<p>現在我們運行模擬：由於默認情況下關節不受控制，因此機器人將解離。在上一階段添加關節時，我們以力/扭矩模式創建了關節，但其電動機或控制器已禁用（默認情況下）。現在，我們可以根據需要調整關節。在我們的案例中，我們希望為每個控制器都提供一個簡單的PID控制器。在關節動態屬性中，點擊“啟用電機”並調整最大扭矩。然後，點擊啟用控制環，然後選擇位置控制（PID）。現在，我們再次運行仿真：機器人應保持其位置。嘗試切換當前的物理引擎，以查看行為在所有受支持的物理引擎之間是否一致。您可以通過相應的工具欄按鈕或在常規動力學屬性中執行此操作。</p>
<p>在仿真過程中，我們現在通過“動態內容可視化和驗證”工具欄按鈕來驗證場景動態內容。現在，將僅顯示物理引擎考慮的項目，並且該顯示使用顏色編碼。</p>
<hr/>
<p><strong></strong></p>
<p><span>40723243          劉子源</span></p>
<p>Model definition<br/>型號定義</p>
<p>Now we are ready to define our model. <br/>現在我們準備定義模型了。</p>
<p>We start by building the model herarchy:<br/>我們從建立模型層次結構開始：</p>
<p>we attach the last dynamic robot link (robot_link_dyn6) to its corresponding joint (robot_joint6) by selecting robot_link_dyn6, then control-selecting robot_joint6, then [Menu bar --&gt; Edit --&gt; Make last selected object parent].<br/>通過選擇robot_link_dyn6，然後控制選擇robot_joint6，然後選擇[菜單欄-&gt;編輯-&gt;創建最後一個選定的對象，將最後一個動態機器人鏈接（robot_link_dyn6）附加到其相應的關節（robot_joint6）</p>
<p>We could also have done this step by simply dragging object robot_link_dyn6 onto robot_link6 in the scene hierarchy.<br/>我們還可以通過簡單地將對象robot_link_dyn6拖到場景層次結構中的robot_link6上來完成此步驟。</p>
<p>We go on by now attaching robot_joint6 to robot_link_dyn5, and so on, until arrived at the base of the robot. <br/>現在，我們將robot_joint6附加到robot_link_dyn5上，依此類推，直到到達機器人的底部。</p>
<p>We now have following scene hierarchy:<br/>現在，我們具有以下場景層次結構：</p>
<p>It is nice and more logical to have a simple name for the model base, since the model base will also represent the model itself.<br/>為模型庫起一個簡單的名字是很好而且更合乎邏輯的，因為模型庫也將代表模型本身。</p>
<p>So we rename robot to robot_visibleBase, and robot_dyn to robot.<br/>因此，我們將robot重命名為robot_visibleBase，並將robot_dyn重命名為robot。</p>
<p>Now we select the base of the hierarchy tree (i.e. object robot) and in the object common properties we enable Object is model base. We also enable Object/model can transfer or accept DNA.<br/>現在我們選擇層次結構樹的基礎（即對像機械手），並在對象公共屬性中啟用``對像是模型基礎''。我們還使對象/模型可以轉移或接受DNA。</p>
<p>A model bounding box appeared, encompassing the whole robot. <br/>出現了一個模型包圍盒，包圍了整個機器人。</p>
<p>The bounding box however appears to be too large: this is because the bounding box also encompasses the invisible items, such as the joints.<br/>但是，邊界框似乎太大：這是因為邊界框還包含不可見的項，例如關節。</p>
<p>We could do the same procedure for all invisible items in our model.<br/>我們可以對模型中的所有不可見項執行相同的過程。</p>
<p>This is also a useful option in order to also exclude large sensors or other items from the model bounding box. We now have following situation:<br/>這也是一個有用的選項，可以將大型傳感器或其他項目也排除在模型邊界框之外。我們現在有以下情況：</p>
<p>We now protect our model from accidental modification. <br/>現在，我們保護模型免受意外修改。</p>
<p>We select all visible objects in the robot, then enable Select base of model instead: if we now click a visible link in the scene, the base of the robot will be selected instead.<br/>我們選擇機器人中的所有可見對象，然後啟用“選擇模型的基礎”：如果現在單擊場景中的可見鏈接，則會改為選擇機器人的基礎。</p>
<p>This allows us to manipulate the model as if it was a single object. We can still select visible objects in the robot via control-shift-clicking in the scene, or by selecting the object in the scene hierarchy. <br/>這使我們可以像對待單個對像一樣操作模型。我們仍然可以通過按住Shift鍵並單擊場景或在場景層次中選擇對象來選擇機器人中的可見對象。</p>
<p>We now put the robot into a correct default position/orientation. First, we save current scene as a reference (e.g. if at a later stage we need to import CAD data that have the same orientation at the curent robot). <br/>現在，我們將機器人置於正確的默認位置/方向。首先，我們將當前場景保存為參考（例如，如果稍後需要在當前機器人上導入方向相同的CAD數據）。</p>
<p>Then we select the model and modify its position/orientation appropriately. It is considered good practice to position the model (i.e. its base object) at X=0 and Y=0.<br/>然後，我們選擇模型並適當修改其位置/方向。將模型（即其基礎對象）定位在X = 0和Y = 0處被認為是一種好習慣。</p>
<p>Then we select the model and modify its position/orientation appropriately.<br/>然後，我們選擇模型並適當修改其位置/方向。</p>
<p>It is considered good practice to position the model (i.e. its base object) at X=0 and Y=0.<br/>將模型（即其基礎對象）定位在X = 0和Y = 0處被認為是一種好習慣。</p>
<p>We now run the simulation: the robot will collapse, since the joints are not controlled by default.<br/>現在我們運行模擬：由於默認情況下關節不受控制，因此機器人將崩潰。</p>
<p>When we added the joints in the previous stage, we created joints in force/torque mode, but their motor or controller was disabled (by default).<br/>在上一階段添加關節時，我們以力/扭矩模式創建了關節，但其電動機或控制器已禁用（默認情況下）。</p>
<p>We can now adjust our joints to our requirements. In our case, we want a simple PID controller for each one of them.<br/>現在，我們可以根據需要調整關節。在我們的案例中，我們希望為每個控制器都提供一個簡單的PID控制器。</p>
<p>In the joint dynamic properties, we click Motor enabled and adjust the maximum torque. <br/>在關節動態屬性中，單擊“啟用電機”並調整最大扭矩。</p>
<p>We then click Control loop enabled and select Position control (PID). We now run the simulation again: the robot should hold its position. <br/>然後，單擊啟用控制環，然後選擇位置控制（PID）。現在，我們再次運行仿真：機器人應保持其位置。</p>
<p>Try to switch the current physics engine to see if the behaviour is consistent across all supported physics engines. <br/>嘗試切換當前的物理引擎，以查看行為在所有受支持的物理引擎之間是否一致。</p>
<p>You can do this via the appropriate toolbar button, or in the general dynamics properties.<br/>您可以通過相應的工具欄按鈕或在常規動力學屬性中執行此操作。</p>
<p>During simulation, we now verify the scene dynamic content via the Dynamic content visualization &amp; verification toolbar button.<br/>在仿真過程中，我們現在通過“動態內容可視化和驗證”工具欄按鈕來驗證場景動態內容。</p>
<p>Now, only items that are taken into account by the physics engine will be display, and the display is color-coded. <br/>現在，將僅顯示物理引擎考慮的項目，並且該顯示使用顏色編碼。</p>
<hr/>
<p><span>40723245          蔡育灃</span></p>
<h4 id="title-content">Webots User Guide</h4>
<p>40723201          吳沛汶</p>
<p></p>
<hr/>
<p>40723204          邱倚瀅</p>
<p>Modifying the Floor</p>
<p>修改地板 </p>
<p>The default RectangleArena PROTO defines a simple floor pinned on the static environment, i.e. without <a href="https://cyberbotics.com/doc/reference/physics">Physics</a> node, and surrounded by walls. Other pre-built floors are available in the Webots objects library. We will now delete the RectangleArena node and add a simple floor that we will manually surround with walls later in this tutorial.</p>
<p>默認的RectangleArena PROTO定義了一個固定在靜態環境上的簡單地板，即沒有Physics節點並且被牆壁包圍。 Webots對像庫中提供了其他預建樓層。現在，我們將刪除RectangleArena節點，並添加一個簡單的地板，在本教程的後面部分將用牆手動將其包圍。</p>
<p><strong>Hands-on 2</strong>: To remove the RectangleArena, select it either in the 3D view or in the scene tree view with a left click and press the Delete key on your keyboard. Alternatively, you can right click on it in the 3D view and select Delete in the context menu (you can also use the context menu directly in the scene tree view). Select the TexturedBackroundLight node and click on the Add button. In the open dialog box, and choose PROTO nodes (Webots Projects) / objects / floors / Floor (Solid)</p>
<p>動手操作2：要刪除RectangleArena，請在3D視圖或場景樹視圖中單擊鼠標左鍵將其選中，然後按鍵盤上的Delete鍵。或者，可以在3D視圖中右鍵單擊它，然後在上下文菜單中選擇“刪除”（也可以直接在場景樹視圖中使用上下文菜單）。選擇TexturedBackroundLight節點，然後單擊“添加”按鈕。在打開的對話框中，然後選擇PROTO節點（Webots項目）/對象/ Floors / Floor（實心）</p>
<p> The newly added Floor PROTO has a default size of 10mx10m, but it is possible to adjust its size, its position and texture by changing the corresponding fields.</p>
<p>新添加的Floor PROTO的默認大小為10mx10m，但是可以通過更改相應的字段來調整其大小，位置和紋理。</p>
<p><strong>Hands-on 3</strong>: In the scene tree view select and expand the Floor. Modify the size field and set it to {1, 1} to resize it to 1mx1m.</p>
<p>動手＃3：在場景樹視圖中，選擇並展開“地板”。修改大小字段並將其設置為{1，1}以將其大小調整為1m x 1m。</p>
<p> The Solid Node</p>
<p>實體節點</p>
<p>This subsection introduces the most important base node in Webots: the <a href="https://cyberbotics.com/doc/reference/solid">Solid</a> node, from which many other nodes derive.</p>
<p>本小節介紹了Webots中最重要的基礎節點：Solid節點，許多其他節點都來自Solid節點。</p>
<hr/>
<p>40723213          杜玗宸</p>
<p><strong>翻譯Webots User Guide</strong></p>
<p>A <a href="https://cyberbotics.com/doc/reference/solid">Solid</a> node represents a <strong>rigid body</strong>, that is a body in which deformation can be neglected. The distance between any two given points of a rigid body remains constant in time regardless of external forces exerted on it. For example a table, a robot finger phalanx or a wheel are rigid bodies. Soft bodies and articulated objects are not rigid bodies. For example, a rope, a tire, a sponge or an articulated robot arm are not rigid bodies. However, an articulated entity can be broken into several rigid bodies.</p>
<p>The physics engine of Webots is designed for simulating rigid bodies only. An important step, when designing a simulation, is to break up the various entities into separate rigid bodies.</p>
<p>To define a rigid body, you will have to create a <a href="https://cyberbotics.com/doc/reference/solid">Solid</a> node. Inside this node you will set up different sub-nodes corresponding to the characteristics of the rigid body. The following <a href="https://cyberbotics.com/doc/guide/tutorial-2-modification-of-the-environment#the-simplest-model-of-a-rigid-body-in-webots-having-a-graphical-representation-a-physical-bounding-object-and-being-in-the-dynamical-environment">figure</a> depicts a rigid body and its sub-nodes. The graphical representation of the <a href="https://cyberbotics.com/doc/reference/solid">Solid</a> node is defined by the <a href="https://cyberbotics.com/doc/reference/shape">Shape</a> nodes populating its children list. The collision bounds are defined in its boundingObject field. The graphical representation and the collision shape are often but not necessarily identical. Finally, the physics field defines if the object belongs to the dynamical or to the static environment. All these sub-nodes are optional, but the physics field needs the boundingObject to be defined.</p>
<p><img alt="" height="293" src="https://s40723213.github.io/cad2019/images/%E6%93%B7%E5%8F%96.PNG" width="346"/></p>
<p><span><span>The simplest model of a rigid body in Webots having a graphical representation, a physical bounding object and being in the dynamical environment.</span></span></p>
<p>The Geometry box (in <a href="https://cyberbotics.com/doc/guide/tutorial-2-modification-of-the-environment#the-simplest-model-of-a-rigid-body-in-webots-having-a-graphical-representation-a-physical-bounding-object-and-being-in-the-dynamical-environment">this figure</a>) stands for any kind of geometrical primitive. In fact, it can be substituted by a <a href="https://cyberbotics.com/doc/reference/sphere">Sphere</a>, a <a href="https://cyberbotics.com/doc/reference/box">Box</a>, a <a href="https://cyberbotics.com/doc/reference/cylinder">Cylinder</a>, etc.</p>
<p>實體節點表示剛體，即可以忽略變形的剛體。剛體上任意兩個給定點之間的距離在時間上保持恆定，而不管施加在其上的外力如何。例如，桌子，機械手指骨或輪子是剛體。軟體和關節物體不是剛體。例如，繩索，輪胎，海綿或關節式機械臂不是剛性體。但是，可以將一個鉸接的實體分解為幾個剛體。</p>
<p><span>Webots</span>的物理引擎僅設計用於模擬剛體。設計仿真時，重要的一步是將各個實體分解為單獨的剛體。</p>
<p>要定義剛體，您將必須創建一個實體節點。在此節點內，您將根據剛體的特性設置不同的子節點。下圖描繪了剛體及其子節點。實體節點的圖形表示由填充其子級列表的<span>Shape</span>節點定義。碰撞範圍在其<span>boundingObject</span>字段中定義。圖形表示和碰撞形狀通常但不一定相同。最後，物理字段定義對像是屬於動態環境還是屬於靜態環境。所有這些子節點都是可選的，但物理場需要定義<span>boundingObject</span>。</p>
<p><img alt="" height="293" src="https://s40723213.github.io/cad2019/images/%E6%93%B7%E5%8F%96.PNG" width="346"/></p>
<p><span>Webots</span>中剛體的最簡單模型，具有圖形表示，物理邊界對象並且處於動態環境中。</p>
<p>幾何框（在此圖中）代表任何類型的幾何圖元。 實際上，它可以用球體，盒子，圓柱體等代替。</p>
<hr/>
<p>40723215          杜彥霆</p>
<p></p>
<hr/>
<p>40723218          林志豪</p>
<p></p>
<hr/>
<p>40723219          林承治</p>
<p></p>
<hr/>
<p>40723237          黃俊翔</p>
<p>DEF-USE Mechanism</p>
<p>DEF-USE 機制</p>
<p>The <strong>DEF-USE mechanism</strong> allows to define a node in one place and to reuse that definition elsewhere in the scene tree. This is useful to avoid the duplication of identical nodes in world files. Moreover, it also allows users to modify several objects at the same time. Here is how it works: first a node is labeled with a DEF string. Then copies of this node can be reused elsewhere with the USE keyword. Only the fields of the DEF node can be edited, the fields of the USE inherit from the DEF node and cannot be changed. This mechanism is dependent on the order of the nodes in the world file. A DEF node should be defined before any corresponding USE node.</p>
<p><span> </span></p>
<p><strong>DEF-USE </strong><strong>機制</strong>允許在一個位置定義節點，並在場景樹的其他位置重用該定義。這對於避免世界檔中相同節點的重複非常有用。此外，它還允許使用者同時修改多個物件。下面是它的工作原理：首先，節點用<span> DEF </span>字串標記。然後，此節點的副本可以使用<span> USE </span>關鍵字在其他地方重用。只能編輯<span> DEF </span>節點的欄位，<span>USE </span>的欄位從<span> DEF </span>節點繼承，不能更改。此機制取決於世界檔中節點的順序。應在任何相應的<span> USE </span>節點之前定義<span> DEF </span>節點。</p>
<p>The two <span><a href="https://cyberbotics.com/doc/reference/sphere">Sphere</a></span> definitions that we have used earlier to define the ball, are redundant. We will now merge these two <span><a href="https://cyberbotics.com/doc/reference/sphere">Spheres</a></span> into only once using the DEF-USE mechanism.</p>
<p> </p>
<p><span><a href="https://cyberbotics.com/doc/reference/sphere"> </a></span>我們之前用於定義球的兩個球體定義是多餘的。現在，我們將使用<span> DEF-USE </span>機制僅將這兩個<span><a href="https://cyberbotics.com/doc/reference/sphere"><span>球體</span></a></span>合併為一次。</p>
<p><strong>Hands-on #6</strong>: Select the first <a href="https://cyberbotics.com/doc/reference/sphere">Sphere</a> node (the child of the <a href="https://cyberbotics.com/doc/reference/shape">Shape</a>) in the scene tree view. The <a href="https://cyberbotics.com/doc/guide/the-scene-tree#field-editor">field editor</a> of the scene tree view allows you to enter the DEF string.</p>
<p> </p>
<p><strong>動手</strong>#6：在場景樹狀檢視中選擇第一個<a href="https://cyberbotics.com/doc/reference/sphere"><span>球體</span></a>節點（<a href="https://cyberbotics.com/doc/reference/shape"><span>形狀</span></a>子節點）。 <a href="https://cyberbotics.com/doc/guide/the-scene-tree#field-editor"> </a>場景樹狀檢視的欄位編輯器允許您輸入<span> DEF </span>字串。</p>
<ol>
<li>Enter BALL_GEOMETRYin this field.</li>
<li>在此欄位中輸入BALL_GEOMETRY。</li>
<li>Select the boundingObjectfield (containing the second <a href="https://cyberbotics.com/doc/reference/sphere">Sphere</a> node), and empty it by right clicking the field in the scene tree and choosing the Delete entry in the context menu that pops up.</li>
<li>選擇邊界物件欄位（包含第二個 <a href="https://cyberbotics.com/doc/reference/sphere">Sphere</a> 節點），然後通過按右鍵場景樹中的欄位並在彈出的內容功能表中選擇"刪除"條目來清空該欄位。</li>
<li>Then, select the boundingObjectfield and click on the Add button, and select the USE / BALL_GEOMETRY in the dialog box.</li>
<li>然後，選擇"邊界物件<span>"</span>欄位並按一下"添加<span>"</span>按鈕，然後在對話方塊中選擇"使用<span>/BALL_GEOMETRY"</span>。</li>
<li>The result is shown in <a href="https://cyberbotics.com/doc/guide/tutorial-2-modification-of-the-environment#def-use-mechanism-on-the-sphere-node-called-ball_geometry">this figure</a>.</li>
<li>結果如下<a href="https://cyberbotics.com/doc/guide/tutorial-2-modification-of-the-environment#def-use-mechanism-on-the-sphere-node-called-ball_geometry"><span>圖</span></a>所示。</li>
</ol>
<hr/>
<p><span>40723242          趙子德</span></p>
<p><strong>Webots User Guide 1:</strong></p>
<p><strong>原文:</strong></p>
<p>Now, changing the radius field of the first <span><a href="https://cyberbotics.com/doc/reference/sphere">Sphere</a></span> node also modifies its boundingObject.</p>
<p>For convenience, the boundingObject field accepts also the <span><a href="https://cyberbotics.com/doc/reference/shape">Shape</a></span> node (rather than the <span><a href="https://cyberbotics.com/doc/reference/sphere">Sphere</a></span> node directly). It would be also possible to use the same DEF-USE mechanism at the <span><a href="https://cyberbotics.com/doc/reference/shape">Shape</a></span> level as shown in <span><a href="https://cyberbotics.com/doc/guide/tutorial-2-modification-of-the-environment#def-use-mechanism-applied-on-the-shape-node-of-a-solid">this figure</a></span>. For now the greatest benefit is being able to also use this <span><a href="https://cyberbotics.com/doc/reference/shape">Shape</a></span> directly for graphical purposes. Later this mechanism will turn out to be very useful for some sensors.</p>
<p><strong>中譯:</strong></p>
<p>現在，更改第一個Sphere節點的半徑字段也會修改其boundingObject。</p>
<p>為了方便起見，boundingObject字段還接受Shape節點（而不是直接接受Sphere節點）。 如圖所示，也可以在Shape級別使用相同的DEF-USE機制。 到目前為止，最大的好處就是也可以直接將此Shape用於圖形目的。 後來，對於某些傳感器，該機制將變得非常有用。</p>
<p><strong>原文:</strong></p>
<p><strong>Hands-on #7</strong>: Create a second ball with the same parameters but using the <a href="https://cyberbotics.com/doc/reference/shape">Shape</a> node (rather than the <a href="https://cyberbotics.com/doc/reference/sphere">Sphere</a> node directly) for the DEF-USE mechanism.</p>
<p><strong>中譯:</strong></p>
<p>動手練習7：使用DEF-USE機制的Shape節點（而不是直接使用Sphere節點）創建具有相同參數的第二個球。</p>
<hr/>
<p><span>40723243          劉子源</span></p>
<p>Now, changing the radius field of the first Sphere node also modifies its boundingObject.<br/>現在，更改第一個Sphere節點的半徑字段也會修改其boundingObject。</p>
<p>For convenience, the boundingObject field accepts also the Shape node (rather than the Sphere node directly). It would be also possible to use the same DEF-USE mechanism at the Shape level as shown in this figure.<br/>為了方便起見，boundingObject字段還接受Shape節點（而不是直接接受Sphere節點）。如圖所示，也可以在Shape級別使用相同的DEF-USE機制。</p>
<p>For now the greatest benefit is being able to also use this Shape directly for graphical purposes. Later this mechanism will turn out to be very useful for some sensors.<br/>到目前為止，最大的好處就是也可以直接將此Shape用於圖形目的。後來，對於某些傳感器，該機制將變得非常有用。</p>
<p>on the Sphere node called BALL_GEOMETRY.<br/>在名為BALL_GEOMETRY的Sphere節點上。</p>
<p>physics 物理<br/>boundingObject<br/>children 孩子們<br/>geometry 幾何<br/>Solid 固體<br/>Physics 物理<br/>USE BALL_GEOMETRY 使用BALL_GEOMETRY<br/>Shape 形狀<br/>DEF BALL_GEOMETRY Sphere DEF BALL_GEOMETRY球體</p>
<p>DEF-USE mechanism applied on the Shape node of a Solid.<br/>Hands-on #7: Create a second ball with the same parameters but using the Shape node (rather than the Sphere node directly) for the DEF-USE mechanism.</p>
<p>在實體的“形狀”節點上應用的DEF-USE機制。<br/>動手練習7：使用DEF-USE機制的Shape節點（而不是直接使用Sphere節點）創建具有相同參數的第二個球。</p>
<hr/>
<p><span>40723245          蔡育灃</span></p>
<br />week15 - 18 << <a href='week15 - 18.html'>Previous</a> <a href='M.A.L.html'>Next</a> >> M.A.L</div>
        
    <!-- footer -->
      <div class="container">
        <div class="row pt-3 mx-auto">
            <p>
            <!-- Link back to Colorlib can't be removed. Template is licensed under CC BY 3.0. -->
            Copyright &copy;<script>document.write(new Date().getFullYear());</script> All rights reserved | This template is made with <i class="icon-heart" aria-hidden="true"></i> by <a href="https://colorlib.com" target="_blank" >Colorlib</a>
            <!-- Link back to Colorlib can't be removed. Template is licensed under CC BY 3.0. -->
            </p>
        </div>
      </div>
    <!-- for footer -->
    
        </div> <!-- for site wrap -->
            <!-- <script src="../cmsimde/static/chimper/js/jquery-3.3.1.min.js"></script> -->
            <script src="../cmsimde/static/chimper/js/jquery-migrate-3.0.1.min.js"></script>
            <script src="../cmsimde/static/chimper/js/jquery-ui.js"></script>
            <script src="../cmsimde/static/chimper/js/popper.min.js"></script>
            <script src="../cmsimde/static/chimper/js/bootstrap.min.js"></script>
            <script src="../cmsimde/static/chimper/js/owl.carousel.min.js"></script>
            <script src="../cmsimde/static/chimper/js/jquery.stellar.min.js"></script>
            <script src="../cmsimde/static/chimper/js/jquery.countdown.min.js"></script>
            <script src="../cmsimde/static/chimper/js/jquery.magnific-popup.min.js"></script>
            <script src="../cmsimde/static/chimper/js/bootstrap-datepicker.min.js"></script>
            <script src="../cmsimde/static/chimper/js/aos.js"></script>
            <!--
            <script src="../cmsimde/static/chimper/js/typed.js"></script>
                    <script>
                    var typed = new Typed('.typed-words', {
                    strings: ["Web Apps"," WordPress"," Mobile Apps"],
                    typeSpeed: 80,
                    backSpeed: 80,
                    backDelay: 4000,
                    startDelay: 1000,
                    loop: true,
                    showCursor: true
                    });
                    </script>
            -->
            <script src="../cmsimde/static/chimper/js/main.js"></script>
        </body></html>
        