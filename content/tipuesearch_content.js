var tipuesearch = {"pages": [{'title': 'Member', 'text': '40723201 \xa0 \xa0 \xa0 吳沛汶 \n 40723204 \xa0 \xa0 \xa0 邱倚瀅 \n 40723213 \xa0 \xa0 \xa0 杜玗宸 \n 40723215 \xa0 \xa0 \xa0 杜彥霆 \n 40723218 \xa0 \xa0 \xa0 林志豪 \n 40723219 \xa0 \xa0 \xa0 林承治 \n 40723237 \xa0 \xa0 \xa0 黃俊翔\xa0 \n 40723242 \xa0 \xa0 \xa0 趙子德 \n 40723243 \xa0 \xa0 \xa0 劉子源\xa0\xa0 \n 40723245 \xa0 \xa0 \xa0 蔡育灃 \n \n', 'tags': '', 'url': 'Member.html'}, {'title': 'Week', 'text': '', 'tags': '', 'url': 'Week.html'}, {'title': 'week10 - 14', 'text': '', 'tags': '', 'url': 'week10 - 14.html'}, {'title': 'week10', 'text': '本周重點 :創建分組倉儲，組長利用fork將組員加入，組員利用pull requests參與倉儲作業 \n Fork倉儲 \n 正向pull request :無權組員修改過的檔案經由new\xa0 pull request，向組長提出申請，經組長確認檔案無誤後進行衝突合併，若無權組員檔案版本過舊將在提出申請前即被擋下. \n 反向 pull request :無權組員檔案版本過舊時，將new\xa0 pull request反向回推至個人分支進行更新.更新也可透過(git pull "你fork的倉儲") \n 操作影片: \n \n 推送流程: \n git pull "fork倉儲網址">開啟近端修改其內容>關閉近端>git add .>git commit -m "修改版次">git push>到自身分支提交new pull request>待組審核後才會呈現在版面上. \n Solidworks 和 NX 繪圖練習\xa0  :\xa0 \xa0\xa0 \n Solidworks  :\xa0\xa0 吳沛汶/邱倚瀅/林承治/劉子源 /蔡育灃 \n NX  : 杜玗宸/林志豪/黃俊翔 /趙子德 \n Solidworks 和 NX 繪圖差異分析 : \n 40723201\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 吳沛汶 \n Solidworks繪圖練習 :\xa0 https://youtu.be/d4LuR_vzE1E \n Solidworks 比較適合新手使用，這個軟體相比 NX 要簡單很多，最容易上手。 \n NX 這個軟體的功能也很強大，而且它的曲面功能現在也越做越好，但是它的軟體介面並不是很友好，特別是工具條，初學者看著會特別亂，工具有時候找很久找不到。 \n 40723204\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0 邱倚瀅 \n Solidworks繪圖練習\xa0\xa0 https://youtu.be/NCWQq-12Jwc \n \n Solidworks和NX差異性分析\xa0 \n 草圖模式  : \xa0Solidworks建立草圖模式分為草圖繪製和 3D 草圖。NＸ分為草圖和在任務環境中繪製草圖。 \n 草圖平面：Solidworks是直接選擇草圖平面，NX在創建草圖時會提示你是選擇現有平面還是創建平面。 \n 參數化：Solidworks是直接定義幾何關係。NX有尺寸約束與幾何約束。 \n 以約束來說，NX可以通過標註直接約束。Solidworks則無此指令。 \n 優點  : \n Solidworks :\xa0 以初學者來說Solidworks相比NX來的容易上手，Solidworks較簡單易學，界面清晰簡潔，具備機械傳動結構建模等基礎功能，適合初階機械設計。 \n NX :\xa0 適用於模具設計、 NC 加工、複雜零件、曲面，做複雜零件和裝配修改非常方便，操作人性化可同步建模。 \n 缺點  : \n Solidworks :\xa0 功能局限性大，只是一個參數化建模，不能做變量化方程的設計，曲面建模較差，模具、限元、運動力學方面相比NX要差。 \n \xa0NX :\xa0 導出的圖檔不利於尺寸參數二次修改，較複雜難上手。 \n 40723213\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0杜玗宸 \n Solidworks和NX差異: \n Solidworks最大優點是操作簡單，新手易上手，其功能也滿足大部分公司設計所需，普及程度高，與其他程式互相導入導出的相容性也不錯。 \n NX雖然操作難度比sw高了一些，但是網路上的教學影片也很多，最大特色在於曲面建模功能強大，編成也方便，只要不過於複雜都應付得來。 \n NX繪圖練習:操作影片 \n \n \n 40723215\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0杜彥霆 \n \n 40723218\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0林志豪 \n 1.NX繪圖練習\xa0 \n \n 2.Soildworks/NX 各自簡單分析差異性 \n Soildworks介面較整齊，使用起來操作較為簡單，適合繪圖初學者使用，在業界受到廣泛使用，但是曲面建模以及模具方面較差。 \n NX的介面較為凌亂，使用起來比較難上手，但是適合用於模具方面加工以及複雜曲面 \n 40723219\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0林承治 \n \n 40723237\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0黃俊翔\xa0 \n \n \n NX繪圖練習: https://www.youtube.com/watch?v=BererErCwgc&feature=youtu.be \n \n \n 40723242\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0趙子德 \n NX練習: \n \n soildworks/nx分析 \n \n Solidworks \n \n 3D曲線支援能力 :支援3D曲線，2D/3D線各別獨立. 平面及軸向鎖定 ：按tab鍵可切換繪製平面簡單方便，直線可鎖定軸向. 鎖點能力 ：一般，很多情況下需要使用relation幫忙定位還好他提供直接在3D線模式下建立補助平面，算是就比較麻煩一點但還能接受. \n 3D曲線編輯 \n 基本上SWX的曲線打上兩個端點之後產生的是一個3 dregree的曲線，含端點總共4個控制點 ， SWX曲線的handler可獨立調整切線方向或是切線延長切線影響範圍，在同類軟體裏面算是相當的好用的調整方式 ， 同時也可以打開控制點的顯示，直接修改控制點的位置 ， 缺點的話就是他的handler若只想針對單一平面調整會有些困難，經常可以看到一些示範影片中調整了上視圖的曲線之後側視圖的就跟著跑掉，一直來回調整 ， 另外調整handler時經常造成閃退，以及handler經常無故消失無法操作是比較頭痛的問題 ， 還有一點比較奇怪的是在開啟遠近透視的情況下，從上視圖拖曳點移動，會發現連垂直位置也受到影響. \n 曲面生成及修改 SWX的曲面生成介面非常好用，可任意不按順序修改構成曲線也可以選擇截斷曲面的位置，這點可大幅減少配合曲面截斷曲線的需要合併線段選擇能力：SWX的Selection Manager也是一個相當好用的功能可以選擇合併不同線段來構成曲面，也是其它軟體比較缺乏的設計 ， 但他的Selectin Manager操作上還是略嫌煩瑣就是。 \n 連續曲率能力(G1/G2/G3..等) 基本上都可支援到G2 – 特有建模方式：應該沒有 – 分析工具 Curvature/Zebra都相當方便易用. \n 顯示能力 曲面反射顯示：開啟顯卡Realview功能後可直接在視圖顯示反射，速度上還算不錯，相當的實用。但缺點是即使作適當調整後仍稍有些過曝感覺. 即時視圖渲染：即時視圖不支援ray tracing，不過其實也不太需要就是. \n 操作介面 指令圖示 ：功能清楚，安排容易上手. 分割視圖 ：可切換分割. 快速視角切換 ：沒有切換視角的小方塊，需要用工具列切換比較不直覺 平移旋轉操作 ：中鍵旋轉，似乎無法自定右鍵功能. \n 執行順暢度 硬體需求 ：繪圖時CPU佔用比其它軟體來的高，隨便畫個曲線都能聽到CPU風扇起飛的聲音。 軟體穩定度 ：不佳，經常遇到閃退情況。 閃退時自動回復功能經常失效，或是乾脆完全都不作用，造成工作進度的損失。 奇怪的問題不少，使用上的體驗並不是很好。 \n \n Creo (Pro/Engineer，ProE) \n \n 優點 1. 硬體效能夠強，可以處理幾千件零組件的計算與畫面移動、旋轉等動作 2. 軟體能順暢處理大型組合件 3. 市購品廠商提供3D CAD模型 \n 缺點: \n 機械設備的零組件少量多樣，不適合大量製造的製程，基本上都是以車、銑、鑽、磨為主，連放電跟線切割都要避免(成本考量)，形狀通常不會太過於複雜，少數會用到鑄造，形狀已經算比較複雜，包括必需考慮脫模角度，所以一般來說，設備零件考慮到加工製造的的成本效益很少會用到曲面。 相對消費性產品考慮量產與外觀，零件製造方法會以鈑金沖壓、塑膠射出為主， 需要公母模的布林計算、鈑金展開、沖壓模或射出模設計，這些都需要用到複雜的形狀與曲面能力，這也是ProE在主要市場消費性電子產品設計上，軟體功能強項發展多在複雜的零件形狀設計(曲面)，以提供外觀設計跟大量製造的模具所需；但是這些曲面、模具設計功能到了機械設計用途就變成一無是處。 \n \n 40723243\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0劉子源\xa0\xa0 \n 1.文件格式:NX的文件格式為.prt；SolidWorks的文件格式為.sldprt。 \n 2.建立草圖方式:NX分為草圖和在任務環境中繪製草圖；SolidWorks分為草圖繪製和3D草圖。 \n 3.草圖平面:NX在創建草圖時會提示你是選擇現有平面還是創建平面；而SolidWorks是直接選擇平面，如果想選擇創建的平面就需要提前創建。 \n 4.參數化:NX分為尺寸約束和幾何約束。繪製草圖時也應該儘量做到完全約束。如果欠約束，NX會告訴你欠幾個約束。如果過約束，NX也會提示。SolidWorks的說法是定義，也需要添加幾何關係，其實道理是一樣的，如果欠定義的話，線的顯示顏色不一樣，但不顯示欠幾個定義。不欠定義的話就是完全定義。 \n 5.快速約束的方式。如下圖，在NX中連續單擊線1，線2，會出現一個臨時的約束工具條，選擇需要的約束即可。 \n sodiworks繪圖練習 : https://www.youtube.com/watch?v=0mVgqw164PI \n \n 40723245\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0蔡育灃 \n 進行Solidworks, NX, Inventor 與 Creo (Pro/E) 的開發緣起/套件安裝/設定流程/零組件繪圖的相關差異與特點分析 \n Solidwork:這套CAD軟體幾乎每一年都有在改良，在它剛推出時就因價格低廉又好上手的強大吸引力，大受好評。 \n NX:是這4套CAD軟體中最早出身的，它比較適合用在繪製模具那種高精度的物品。 \n Inventor:目前它是最便宜的3D CAD軟體，性質上跟solidworks差不多。 \n Creo (Pro/E): 作為當今世界機械 CAD/CAE/CAM 領域的新標準而得到業界的認可和推廣，是現今主流的模具和產品設計三維 CAD/CAM 軟件之一。 \n Solidworks繪圖操作影片:\xa0 https://www.youtube.com/watch?v=SLB6WYHcBDw&feature=emb_logo \n \n', 'tags': '', 'url': 'week10.html'}, {'title': 'SolidWorks', 'text': '1993年 \n 創始人 Jon Hirschtick 招募了一個工程師團隊，旨在使 3D CAD 軟體更容易上手。 Hirschtick 從廣受好評的麻省理工學院二十一點隊的成員中籌得 100 萬美元，開始了他的新事業。該團隊的目標是構建一個基於 Windows 平台的易於使用且價格合理的軟體。這在當時真的是革命性的存在，當時所有其他流行的 CAD 系統都是在 Unix 上構建的。經過幾年的開發，最初發布的 SolidWorks 終於來了 \n 1995年 \n \n 與其他 CAD 系統的 18,000 美元相比， SolidWorks 的售價僅為 4,000 美元。 \n 該軟體更易於使用：與市場上其他 CAD 軟體相比，用戶只需 3 個月的使用經驗就可以輕鬆上手。易用性的很大一部分原因在於它採用了現代著名的 Windows 介面。 \n 模型的可視化是前所未有的。在光線充足的陰影環境中的構建功能與傳統建模空間形成鮮明對比，傳統建模空間僅顯示黑色背景下的線框。 \n 我們現在熟悉的類似 FeatureManager 用於顯示模型的構建歷史。 \n 零件，組件和圖紙從一開始就可用。用戶無法在組件中應用配合，但仍可將組件放置到位。 \n \n 1996年 \n \n 介紹了上下建模。允許使用自上而下的裝配建模方法。 \n 用戶現在可以在裝配中使用配合併捕捉動態裝配運動。除了干擾檢測，用戶還可以更輕鬆地驗證形狀，適合度和功能。 \n 拖放功能可將一個裝配體零部件移動到另一個裝配體中。 \n 部分配置。 \n 自動化物料清單。只有一種方法沒有自定義選項，但它很有效。 \n \n 1997年 \n \n 鈑金功能首次發布。 \n 標準庫功能推出。 \n Loft功能現在可以使用引導曲線。 \n SolidWorks 被 \xa0 Dassault Systemes （達索公司）收購。 \n 面部圓角介紹。 \n 裝配配置。 \n 完全可定製的組件爆炸視圖。 \n SolidWorks Viewer作為免費產品推出，可與非 CAD 用戶共享設計，並在與外部方共享數據時保護智慧財產權。 \n \n 1998年 \n \n 已發布功能面板，現在與設計庫的功能類似。可以拖放到模型上的預製功能。 \n 草圖診斷可幫助用戶理解草圖不適用於特定特徵的原因。 \n Lofts和 Sweeps 的相切控制。 \n 組合件封包 (Assembly Envelopes) 。 \n 智能配合在建造組件中更多地使用拖放式自動化。 \n 隨著用戶不斷建造越來越大的組件，輕量級組件可以幫助提高性能。 \n 表面處理工具首次推出。 \n FeatureWorks用於導入文件，能夠更有效地使用來自其他軟體的現有 3D 數據。 \n 首次 CSWP 考試發布。它是手寫的，並通過郵件發送。 \n \n 1999年 \n \n Palm Springs的第一個 SolidWorks World 。 \n 拖動組件時對組件的實時碰撞檢測。 \n 3D草圖介紹。 \n 管道模塊發布。 \n 2D命令模擬器有助於縮小與以前 AutoCAD 用戶的差距。 \n \n 2000年 \n \n 發布 eDrawings 。 \n 實現了 Hole Wizard 接口。 \n 表面處理更有用，能夠編織，修剪和延伸表面。 \n SolidWorks Explorer。 \n 動態間隙檢測可驗證裝配部件之間的最小間隙。 \n \n 2001年 \n \n 鏡像組件中的組件。 \n 引領互動。以前，在任何 CAD 系統中，只要選擇了命令，軟體就會在模型頂部顯示整個對話框。 SOLIDWORKS 開始廢除這一點，並轉向我們現在知道的 PropertyManagers ，並將陰影標註返回到模型。 \n 現在允許靈活的子組件進一步捕捉準確的裝配運動。 \n 介紹填充表面命令。 \n DXF / DWG導入嚮導發布。 \n 3D Meeting（ 3D 會議），最終在幾個版本之後退出。利用 Microsoft Live Meeting 並允許與螢幕共享進行實時同步會議。 \n 運動模擬功能現在可以捕捉組件中移動的組件的實際物理動態。 \n 介紹大型裝配模式。 \n 實現了 2D 到 3D 轉換工具，以便將 2D CAD 數據輕鬆轉換為功能齊全的 3D 模型。 \n 介紹 SolidWorks Office ，將常用的插件如 PhotoWorks ， Toolbox ， Utilities 和 FeatureWorks 打包成一個產品。 \n Dassault Systemes收購了 SRAC 並開始將仿真引入主流設計流程。 \n \n 2003年 \n \n COSMOSXpress是第一款 Xpress 產品，它為每個桌面帶來了簡單的零件驗證。 \n 3DContentCentral為用戶提供了一個交互和共享模型的社區。 \n 多體零件設計。這是一個非常大的問題，現在是焊接，鈑金和模具設計的基礎。 \n 收購了 PDMWorks 並引入了 SolidWorks Office Professional 軟體包。開始將 PDM 作為每個客戶提供的一部分。 \n \n 2004年 \n \n 介面更新，包括 CommandManager ，彈出 FeatureManager 和 PropertyManager 和 ConfigurationManager 的管理器視圖選項卡。 \n 介紹了 Mold Tools （模具工具）和 Weldments （焊件）。 \n 實施 Auto Balloon 命令以匹配物料清單物料編號中的 balloon 編號。 \n 限制配合以捕捉更複雜的裝配運動。 \n 推出了 RealView Graphics ，以便隨時提供更逼真的圖像。 \n \n 2005年 \n \n 繪圖比較，為用戶提供工具來比較兩個圖紙之間的變化。 \n Flex功能。 \n 電氣布線，與管道布線一起使用。 \n 在圖紙中自動標註，以捕捕捉模型中已定義的尺寸。 \n 能夠繪製無限的線條。 \n SolidWorks Rx發布，旨在提供幫助技術支持更好地去識別問題。 \n \n 2006年 \n \n 發布 Smart Components 功能，允許為硬體之類的物件安裝智能裝配組件。 \n 介紹填充圖案。 \n 介紹草圖塊。 \n 顯示狀態。 \n 設計檢查器，允許用戶根據公司標準動態檢查他們的模型。 \n 添加了相機視圖功能。 \n 發布 SolidWorks Office Premium （白金版）軟體包，包括 Routing ， COSMOSWorks 和 \xa0 COSMOSMotion 進行模擬，以及 ScanTo3D 。 \n \n 2007年 \n \n SWIFT工具可幫助設計人員在提供自動化解決方案時動態了解模型存在問題或錯誤的原因。 \n 可在組件中使用皮帶，鏈條和齒輪功能。 \n 用於表面處理的自由形式命令。 \n 介紹 Enterprise PDM 。 \n \n 2008年 \n \n 使用新的菜單欄和 CommandManager 布局對用戶介面進行全面檢修和現代化優化。上下工具欄和快捷工具欄首次可用。所有這些介面組件現在都可以完全自定義。 \n Instant3D，提供拖動和操縱幾何體的功能，可輕鬆測試不同的設計概念。 \n 發布 TolAnalyst 。 \n 設計剪貼畫，通過剖析現有數據以便在另一個模型中重複使用，可以更輕鬆地重用現有的 2D 和 3D 數據。 \n 推出 DriveWorksXpress 和 DFMXpress 。 \n \n 2009年 \n \n PhotoView360圖像渲染作為第一個渲染器引入，以訪問處理器的多核功能。 \n SpeedPak現在可用於簡化裝配中的組件。 \n 為追求更高目標，所以引入傳感器。 \n CircuitWorks發布並添加到 SolidWorks Office Premium （白金版）軟體包中。 \n 發布 3DVIA Composer 。 \n \n 2010年 \n \n 現在提供可持續發展方案，幫助用戶了解其設計對環境的影響。 \n 快速標註尺寸使得創建細節圖更加容易。 \n 介紹基於事件的運動模擬。 \n 首次提供滑鼠手勢快捷鍵。 \n 現在可以進行多體鈑金建模。 \n \n 2011年 \n \n PhotoView360完全集成到 SolidWorks 介面中。 \n 現在可以使用 Walk-through （走查）功能。 \n 引入了 Defeature 工具以幫助限制模型中的智慧財產權數量。 \n 現在可以在 Simulation 中使用平面簡化。 \n 自動排列圖紙中的尺寸。 \n \n 2012年 \n \n 方程式編輯器經過徹底檢修後，更加用戶友好。 \n 介紹 Large Design Review 。 \n Feature Freeze現在可以讓用戶更好地控制性能。 \n 鈑金增強：邊線法蘭的更多選擇，引入掃描法蘭，使用的成型工具更加人性化。 \n 發布成本計算加載項。 \n \n 2013年 \n \n View Orientation有一個對話框，不再只是在工具欄上了。還引入了選擇器多維數據集以及保存視圖功能以便之後使用。 \n 以前的版本文件互操作性： 2013 文件現在可以在 2012 SP5 中打開。 \n 介紹 Conic 草圖實體。 \n 相交功能。 \n Customer Portal（客戶門戶網站）上提供了 CAD Admin Dashboard （ CAD 管理員儀錶板）。 \n \n 2014年 \n \n 能夠通過上下工具欄快捷方式添加標準配合。 \n 替換草圖實體使用戶能夠用新的實體替換舊實體並仍然維護下游引用。 \n 推出了鈑金中的 Lofted Bend 功能。 \n 能夠創建 Conic Fillets （圓錐倒角）。 \n 樣式樣條草圖命令。 \n 自動縮放第一個草圖。現在，在草圖上創建第一個維度時，所有實體都會自行調整大小以進行縮放。 \n 能夠配置結構成員配置文件。現在允許配置輪廓草圖，這大大改變了需要組織的文件數量。 \n MySolidWorks作為能夠提供自學培訓以及所有 SolidWorks 的在線資源社區發布。 \n \n 2015年 \n \n 動態參考可視化，幫助用戶了解父 / 子關聯。 \n 引入了選擇集，以便於重複使用幾何選擇組合。 \n 能夠直接從 SolidWorks 進行 3D 列印。 \n Simulation中的疲勞分析。 \n Profile center mate（輪廓中心配合）。 \n 發布 SolidWorks MBD 。 \n \n 2016年 \n \n 用戶介面重新設計，包括更好地支持高解析度顯示器。 \n 藍色 / 灰色盤默認採用傳統配色方案。 \n 引入了選擇麵包屑，使相關命令更易於訪問。 \n 實現 Mate Controller 工具，以更加可訪問的方式捕捉裝配定位。 \n 能夠全局替換失敗的配合實體。 \n 介紹 Thread 功能。 \n 發布 PDM Standard （標準版）並添加到 SolidWorks Professional 專業版軟體包中。 \n SolidWorks Visualize作為獨立的圖片渲染應用程式發布。 \n \n 2017年 \n \n 引入 3D 互連以簡化不同文件類型與 SolidWorks 的協作。 \n Asset Publisher具有 ground plane （地層）和 magnetic mates （磁配對），可輕鬆實現大型裝配布局。 \n 引入了 Advanced Hole （高級孔）功能。 \n 增強了 Wrap 功能，可在更多類型的面選擇上創建幾何體。 \n 陰影草圖輪廓增強選擇和操作功能。 \n \n 2018年 \n \n SolidWorks啟動時的歡迎對話框。 \n 用戶設置現在可以登錄。新發布的在線許可也可以遵循此登錄，在需要在多台計算機上使用 SolidWorks 時為用戶提供另一種選擇。 \n 選擇幾何圖形，允許用戶忽略幾何圖形並在其上選擇其他實體。 \n 引入了標籤和插槽功能，自動執行以前在鈑金和焊件中常用的手動方法。 \n 能夠鏡像 3D 草圖中的實體。 \n 首次使用筆，觸屏和基於手勢的草圖繪製功能。 \n 引入拓撲仿真分析。 \n \n 2019年 \n \n 顯著改進裝配性能。 \n Silhouette defeature命令，簡化了從模型中刪除細節以提高性能或保護智慧財產權的過程。 \n 能夠按狀態對 mates 進行分組。 \n 部分倒角和圓角。 \n 將圖像轉換為網格 / 凹凸貼圖，從圖像文件創建實際的 3D 幾何體。 \n \n 原文網址： https://kknews.cc/news/l9vp3ne.html 參考資料 (1): https://kknews.cc/zh-tw/news/ey5ojpy.html \n 參考資料 (2): https://kknews.cc/news/l9vp3ne.html \n', 'tags': '', 'url': 'SolidWorks.html'}, {'title': 'NX', 'text': '1960年 \n McDonnell Douglas Automation 公司成立 \n 1976年 \n 收購了Unigraphics CAD/CAE/CAM系統的開發商——United Computing公司，UG的雛形問世 \n 1983年 \n UG 上市 \n 1986年 \n Unigraphics吸取了業界領先的、為實踐所證實的實體建模核心——Parasolid的部份功能 \n \n \n 1989年 \n Unigraphics宣布支持UNIX平台及開放系統的結構，並將一個新的與STEP標準兼容的三維實體建模核心Parasolid引入UG \n 1990年 \n Unigraphics作為McDonnell Douglas（波音飛機公司）的機械CAD/CAE/CAM的標準 \n 1991年 \n Unigraphics開始了從CAD/CAE/CAM大型機版本到工作站版本的轉移 \n 1993年 \n Unigraphics引入複合建模的概念，可以實體建模、曲線建模、框線建模、半參數化及參數化建模融為一體 \n 1995年 \n Unigraphics首次發布了Windows NT版本 \n 1996年 \n Unigraphics發布了能自動進行干涉檢查的高級裝配功能模塊、最先進的CAM模塊以及具有A類曲線造型能力的工業造型模塊：它在全球迅猛發展，占領了巨大的市場份額，已經成為高端及商業CAD/CAE/CAM應用開發的常用軟體 \n 1997年 \n Unigraphics新增了包括WAVE（幾何連結器）在內的一系列工業領先的新增功能。WAVE這一功能可以定義、控制、評估產品模板，被認為是在未來幾年中業界最有影響的新技術 \n 2000年 \n Unigraphics發布了新版本的UG17，最新版本的，是UGS成為工業界第一個可以裝載包含深層嵌入「基於工程知識」（KBE）語言的世界級MCAD軟體產品的供應商 \n 2001年 \n Unigraphics發布了新版本UG18，新版本對舊版本的對話框進行了調整，使得在最少的對話框中能完成更多的工作，從而簡化了設計 \n 2002年 \n Unigraphics發布了 UG NX1.0 .新版本繼承了UG18的優點，改進和增加了許多功能，使其功能更強大，更完美 \n 2003年 \n Unigraphics發布了新版本 UG NX2.0 \xa0 。新版本基於最新的行業標準，它是一個全新支持PLM的體系結構。EDS公司同其主要客戶一起，設計了這樣一個先進的體系結構，用於支持完整的產品工程 \n 2004年 \n Unigraphics發布了新版本的 UG NX3.0 ，它為用戶的產品設計與加工過程提供了數字化造型和驗證手段，。它針對用戶的虛擬產品的設計和工藝設計的需要，提供經過實踐驗證的解決方案 \n 2005年 \n Unigraphics發布了新版本的 UG NX4.0 .它是嶄新的NX體系結構，使得開發與應用更加簡單和快捷 \n \n \n 2007年04月 \n UGS公司發布了 NX 5.0 \xa0 – NX的下一代數字產品開發軟體，幫助用戶以更快的速度開發創新產品，實現更高的成本效益 \n 2008年06月 \n Siemens PLM Software發布 UG NX 6.0 ，建立在新的同步建模技術基礎之上的NX 6將在市場上產生重大影響。同步建模技術的發布標誌著NX的一個重要里程碑，並且向MCAD市場展示Siemens的鄭重承諾。 NX 6將為我們的重要客戶提供極大的生產力提高 \n 2009年10月 \xa0 \n 西門子工業自動化業務部旗下機構、全球領先的產品生命周期管理（PLM）軟體與服務提供商Siemens PLM Software 宣布推出其旗艦數字化產品開發解決方案NX 軟體的最新版。 UG NX 7.0 引入了「HD3D」（三維精確描述）功能，即一個開放、直觀的可視化環境，有助於全球產品開發團隊充分發掘PLM信息的價值，並顯著提升其制定卓有成效的產品決策的能力。此外，NX 7.0還新增了同步建模技術的增強功能。修復了很多6.0所存在的漏洞，穩定性方面較6.0有很大的提升 \n 2010年5月20日 \n Siemens PLM Software在上海世博會發布了功能增強的NX7最新版本（ UG NX 7.5 ），NX GC 工具箱將作為NX 7最新版本的一個應用模塊與NX 7一起同步發布。NX GC 工具箱是為滿足中國用戶對NX特殊需求推出的本地化軟體工具包。在符合國家標準（GB）基礎上，NX GC 工具箱做了進一步完善和大量的增強工作 \n 2011年09月\xa0 \n Siemens PLM Software發布了 UG NX 8.0 \n 2012年10月 \n Siemens PLM Software發布了 UG NX 8.5 \n 2013年10月 \n Siemens PLM Software發布了 UG NX 9.0 \n 2014年8月 \n Siemens PLM Software發布了 UG NX 10.0 \n 2016年8月 \n Siemens PLM Software發布了 UG NX 11.0 \n 2017年10月 \n Siemens PLM Software發布了 UG NX 12.0 \n \n \n 參考網址: https://kknews.cc/zh-tw/news/j4l9pnl.html \n', 'tags': '', 'url': 'NX.html'}, {'title': 'Creo Parametric', 'text': 'Pro/E是美國參數技術公司 （ Parametric Technology Corporation ，簡稱 PTC ）的重要產品，在目前的三維造型軟件領域中佔有著重要地位。 \xa0 pro-e 作為當今世界機械 CAD/CAE/CAM 領域的新標準而得到業界的認可和推廣，是現今主流的模具和產品設計三維 CAD/CAM 軟件之一。 \n 第一個提出了參數化設計的概念，並且採用了單一數據庫來解決特徵的相關性問題。另外，它採用模塊化方式，用戶可以根據自身的需要進行選擇，而不必安裝所有模塊。 \xa0 Pro/E 的基於特徵方式，能夠將設計至生產全過程集成到一起，實現並行工程設計。它不但可以應用於工作站，而且也可以應用到單機上。 \n 參數化設計 : \n 相對於產品而言，可以把它看成幾何模型，而無論多麼複雜的幾何模型，都可以分解成有限數量的構成特徵，而每一種構成特徵，都可以用有限的參數完全約束，這就是參數化的基本概念。 \n 基於特徵建模 : \n Pro/E是基於特徵的實體模型化系統，工程設計人員採用具有智能特性的基於特徵的功能去生成模型，腔、殼、倒角及圓角，您可以隨意勾畫草圖，輕易改變模型。這一功能特性給工程設計者提供了在設計上從未有過的簡易和靈活，特別是在設計系列化產品上更是有得天獨到的優勢。 \n 單一數據庫 : \n Pro/Engineer是建立在統一基層上的數據庫上，不像一些傳統的 CAD/CAM 系統建立在多個數據庫上。所謂單一數據庫，就是工程中的資料全部來自一個庫，使得每一個獨立用戶在為一件產品造型而工作，不管他是哪一個部門的。換言之，在整個設計過程的任何一處發生改動，亦可以前後反應在整個設計過程的相關環節上。例如，一旦工程詳圖有改變， NC （數控）工具路徑也會自動更新；組裝工程圖如有任何變動，也完全同樣反應在整個三維模型上。這種獨特的數據結構與工程設計的完整的結合，使得一件產品的設計結合起來。這一優點，使得設計更優化，成品質量更高，產品能更好地推向市場，價格也更便宜。 \n 直觀裝配管理 : \n Pro/ENGINEER的基本結構能夠使您利用一些直觀的命令，例如“貼合”、“插入”、“對齊”等很容易的把零件裝配起來，同時保持設計圖。強大的功能支持大型複雜裝配體的構造和管理，這些裝配體中零件的數量不受限制。 \n 參考資料 : https://baike.baidu.com/item/Pro-E/4924172 \n \n', 'tags': '', 'url': 'Creo Parametric.html'}, {'title': 'SDRC', 'text': 'SDRC由工程師組成，並由當時的辛辛那提大學副教授 Jason R. Lemon 博士於 1967 年領導，是一家專門研究結構 動力學或機械零件振動的諮詢公司。美國鋼鐵公司是主要客戶和早期投資者，直到 80 年代初將其股票出售給通用電氣 。 \n 為了幫助進行諮詢，該公司編寫了模擬和預測振動的軟件。公司開始要求使用該軟件的權利，因此 SDRC 進入了軟件市場。在 70 年代， SDRC 成為有限元和建模公司，而在 80 年代和 90 年代， SDRC 成為實體建模和分析領域的領先公司之一。 \xa0 SDRC （檸檬）是 70 年代最早創造 “ MCAE” （機械計算機輔助工程 ）一詞的機構之一。 \xa0 Lemon 博士於 1982 年離開 SDRC ，並於 1983 年由國際 TechneGroup Incorporated 成立了一家新公司。專注於在產品開發的早期將 CAE 應用於主導設計（一種稱為 CP / PD （並行產品和流程開發）的方法）。 \n 在 SDRC 率先推出的多項技術中，由於與 Control Data 的合資企業，它是最早引入產品生命週期管理（ PLM ）解決方案的公司之一。產品 Metaphase 最終成為 SDRC 的獨家財產。 \n 參考資料 : https://en.wikipedia.org/wiki/SDRC \n', 'tags': '', 'url': 'SDRC.html'}, {'title': 'week12', 'text': '利用NX12或NX3 進行NX導引，分章節閱讀及操作： \n \n 40723201\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 吳沛汶 \n 第1章—簡介 \n \u3000\u3000現代製造環境可以通過提供的種類越來越多的產品，小批量和更高的質量在提高全球競爭的背景下的模式為特徵。除非行業以更高的質量，更低的成本和更短的交付時間推出新產品，否則它們就無法在全球競爭中生存。國際競爭激烈，技術工人的供應減少。 隨著計算能力的巨大變化和用於設計和生產的軟件工具的廣泛可用性，現在工程師都使用電腦輔助設計（CAD），電腦輔助製造（CAM）和電腦輔助工程（CAE）系統來自動化設計和生產過程。現在這些技術每天都用於各種不同的工程任務。 \n \u3000\u3000以下是產品實現過程中如何使用CAD、CAM和CAE技術的簡要說明。 \n • 電腦 輔助設計– CAD \n \xa0 \xa0 \xa0 CAD技術是涉及使用計算機系統協助創建，修改，分析和優化設計。 \n • 電腦輔助製造– CAM \n \xa0 \xa0 CAM技術涉及到計算機系統規劃管理，並與工廠的生產資源的控制通過計算機接口的製造業務。 \n • 電腦 輔助工程– CAE \n \xa0 \xa0 CAE技術使用計算機系統來分析CAD創建的產品的功能，從而使設計人員可以模擬和研究產品的性能，從而可以優化和優化設計。 \n 這本原文書是針對有興趣學習如何使用NX 12設計機械零件和組件的學生和工程師編寫的。學習使用NX 12對於學習如何使用其他CAD系統（例如PRO-E和CATIA）也將非常有價值。\xa0 \n \n \u3000\u3000第２章 介紹了 NX 12 的基本知識，從開始會議到通過練習基本功能（如打印、保存和退出）來熟悉 NX 12 佈局。它還簡要介紹了坐標系、圖層、各種工具箱和其他重要命令，這些將在後面的章節中使用。 \n \u3000\u3000 第３章 提出素描的概念。它描述瞭如何創建草圖以及給出幾何和尺寸約束。本章非常重要，因為當今的組件的幾何形狀非常複雜且僅憑基本特徵很難建模。 \n \u3000\u3000零件的實際設計和建模始於 第４章 它描述了不同的功能，例如參考功能、掃描功能和原始功能，以及如何使用這些功能創建設計。對特徵執行各種特徵操作。 \n \u3000\u3000 第５章 您將從中學習如何從零件模型創建工程圖，在本章中，我們將演示如何通過添加視圖，標註零件圖紙的尺寸以及修改圖紙中的各種屬性（例如文本大小、箭頭大小和公差）來創建圖紙。 \n \u3000\u3000 第６章 講組裝建模的概念及其術語。它描述了 TopDown 建模和 Bottom \n \u3000\u3000 第７章 引入自由形式的建模。將演示曲線和平滑表面建模的方法。 \n \u3000\u3000 第８章 簡要介紹了 NX 12 中用於有限元分析的設計仿真。 \n \u3000\u3000 第９章 是將設計的模型實施到加工環境中進行加工的實時經驗。本章介紹刀具路徑的生成、驗證和仿真，以創建 CNC （電腦數字代碼），以從多軸甚至先進的 CNC 機床生產設計零件。 \n \u3000\u3000每章中使用的示例和練習題都經過精心設計，最終將在本章中進行統整。 由於這一獨特功能，您應該保存在每一章中創建的所有模型。 \n 40723204\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0 邱倚瀅 \n NX模擬介紹操作\xa0 :\xa0\xa0 https://youtu.be/gFpu92G0dJk \n \n 40723213\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0杜玗宸 \n \n 40723215\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0杜彥霆 \n \n 40723218\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0林志豪 \n 第4章-三維建模 \n 4.1功能類型 表單特徵有六種類型：基元，參考特徵，掃描特徵，刪除功能，提取功能和用戶定義的功能。 與以前的版本相似，NX 12存儲插入菜單選項下的所有表單功能。 表單功能也可以在表單功能工具欄 \n 4.2基本原則 基本特徵是其他許多基礎特徵可以創建功能。 基本圖元是塊圓柱體，圓錐體和球體。 基元是非關聯的這意味著它們與用於創建它們。請注意，通常使用掃掠特徵來創建 原始而不是此處提到的命令。 \n 4.3參考功能 基準平面是可以在構建其他對象時用作基本特徵。 他們協助創建功能圓柱體，圓錐體，球體和旋轉實體沒有平坦表面的物體，以及還有助於創建除垂直於目標實體的面。 我們將按照一些簡單的步驟進行練習特徵。 首先，我們將創建一個從基準面偏移的基準平面。 \n 4.4掃描功能 這裡使用實用的方法介紹了兩個重要的掃掠特徵（拉伸和旋轉）示例是葉輪下殼體的延續，我們從前一章。 \n 4.5刪除功能 刪除功能允許您刪除現有對象的一部分以創建具有以下內容的對象設計中的其他功能。 \n 4.6功能操作 功能操作是在基本的“表單功能”上執行的，以平滑拐角，創建錐度，進行螺紋加工，實例化以及將某些實體從其他實體中減去。 一些功能操作說明如下。 \n 4.7例子 ➢創建一個新文件並將其另存為Impeller_hexa-bolt.prt ➢選擇插入→設計特徵→圓筒 ➢圓柱體應指向正ZC方向與中心設置在原點並具有以下內容尺寸：直徑= 0.25英寸 高度= 1.5英寸現在，在現有氣缸。 \n 4.8標準零件庫 一種更好，更快的建模標準零件（例如螺栓，螺母，銷，螺釘和墊圈）的方法 正在使用標準零件庫。 例如，要建模六角螺栓， ➢選擇重用庫→重用示例→標準零件→ANSI英寸→螺栓 ➢右鍵單擊六角頭 ➢點擊開源文件夾 ➢打開六角螺栓AI.prt \n 4.9同步技術 NX提供的重要且獨特的功能之一，除了“設計功能”和“自由格式建模是同步技術。 使用同步中可用的選項在“建模應用程序”選項卡的功能區欄中的“建模”組，用戶可以修改複雜沒有模型歷史樹並且不知道特徵關係和依賴性。 “推拉”選項可用於使用面，邊來修改3D模型和橫截面。 NX 12支持同步建模，可與以下版本的3D模型一起使用 除標準外，CATIA，Pro /ENGINEER®，SolidWorks®和AutodeskInventor®格式，包括IGES，ISO / STEP和JT。 \n 4.10練習 \n 個人操作影片 \n \n 40723219\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0林承治 \n NX第五章摘要 :\xa0 https://s40723219.github.io/cad2019/content/week10~14.html \n \n 40723237\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0黃俊翔\xa0 \n \n 40723242\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0趙子德  (第七章) \n NX解說(第七章): \n 第7章-自由曲面建模: \n 要創建自由形式特徵，首先需要一組點，曲線，圖紙或實體的邊緣，面 片材或固體或其他物體。 以下各節介紹了一些您可以使用的方法 可以使用自由格式功能來創建模型。 \n 7.1概述: \n 在NX 12中，“自由格式功能”選項位於菜單→插入→ 表面/網格表面/掃掠/法蘭表面和菜單→編輯→表面更高級 操作。 您可以通過多種方式從現有的方式創建自由格式功能. \n 7.1.1從點創建自由特徵: \n 構建曲面(From Menu, click on Insert → Surface): \n (圖一)\xa0 \xa0 \xa0 \xa0 \xa0\xa0 (圖二)\xa0 \xa0 \xa0 \xa0 \xa0\xa0 (圖三) \n 1.Four Point Surface:如果有四個角點 2.Through Points:如果點形成矩形陣列 3.Through Points:如果定義的點形成矩形陣列 \n 7.1.2從部分創建自由格式功能: \n 利用曲線和邊緣創建自由曲面(From Menu, click on Insert → Mesh Surface): \n \xa0(圖一)\xa0 \xa0 \xa0 \xa0 \xa0\xa0 \xa0(圖二)\xa0 \xa0 \xa0 \xa0(圖三)\xa0 \xa0 \xa0 \xa0(圖四) \n 1.Ruled (圖一) ：如果您有兩個大致相同的線平行 (圖三) 2.Through Curves (圖二)\xa0 ：如果大約三個或更多線平行 (圖四) \n 若構造幾何包含兩個或多個線（曲線，面，邊線）以及彼此平行的一個或多個截面 垂直於第一組曲線（參考線）使用下列兩種方式. \n \xa0 (圖一)\xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0 \xa0 (圖二) \xa0 \xa0 \xa0 \xa0 \xa0 (圖三)\xa0 \xa0 \xa0 \xa0 (圖四) \n 1.Through Curve Mesh(圖一): 如果至少有四個截面，則可使用.[弦在每個方向上都存在至少兩個弦（平行和垂直）] (圖三) \n 2.Swept(圖二)\xa0: 如果至少兩個部分線段大致相同，則可使用.[垂直（從菜單中，選擇插入→掃描）] (圖四) \n 7.1.3從面孔創建自由特徵: \n \xa0(圖一)\xa0 \xa0 \xa0 \xa0 \xa0\xa0 \xa0(圖二)\xa0 \xa0 \xa0 \xa0 \xa0(圖三)\xa0 \xa0 \xa0\xa0 \xa0(圖四) \n 1.Offset Surface(圖一): 如果要偏移的面（From Menu, click on Insert →Offset/Scale） \xa0(圖三) \n 2.Extension(圖二): 如果您有3D曲線和邊緣曲線 （Click on the Insert →Flange Surface →Extension） (圖四) \n 7.2自由格式功能建模: \n 進行一些自由結構建模的練習(structured points, a point cloud, curves and faces) \n 7.2.1用點建模 \n 1.打開文件freeform_thrupoints.prt➢右鍵單擊 Toolbars，並確保已選中“Surface Toolbar” \n \n 你會看到 \n \n \n 2.選擇 Insert →Surface →Through Points \n 3.單擊Toolbar圖標 \n 4.對於補丁類型，選擇多個 ➢對於封閉，選擇都不 ➢對於行度和列度，輸入3。 ➢點擊確定 \n \n 5.單擊全部鏈接 ➢選擇頂部起點和底部終點 最左行的點，如下圖所示 \n \n \n ➢重複相同的步驟選擇前四行點之後，將 彈出一個窗口(圖一) ，詢問是否所有點 指定，或者如果您想指定另一行 ➢選擇指定另一行，直到所有行都被指定的 ➢指定所有行後，選擇“指定所有點” ➢單擊“通過點”窗口中的“取消”您將看到如下所示的 表面(圖二) \n (圖一) (圖二) \n 7.2.2使用雲點建模 \n 打開freeform_cloud.prt \n \n ➢ 選擇“插入”→“曲面”→“擬合曲面”or➢單擊 將出現以下介面 ➢通過單擊屏幕上的所有點來選擇 雲點。 ➢在“適合方向”下拉菜單中，選擇“最佳”適合於. 這匹配點雲坐標 系統與原始系統 ➢將U和V度的默認值更改為3 ➢ 點擊確定 \n \n 7.2.3使用曲線建模: \n 打開freeform_thrucurves_parameter.prt \n \n 選擇“ Insert ”→“Mesh Surface”→“Through Curves” or ➢單擊 ➢選擇第一部分線段，如下所示。 確認選擇左側的某個位置弧線 \n \n ➢ 點擊鼠標中鍵MB2或單擊“添加新的 ” \n or ➢單擊與第一個相似的下一條曲線，然後單擊 鼠標中鍵MB2。 你可以看到一個表面 如圖所示，在兩條曲線之間生成 \n \n 重複相同的步驟以選擇其餘線段。 記住點擊MB2（或添加新集）選擇每條曲線後。 ➢對於對齊(Alignment)，選擇參數 ➢對於補丁(Patch Type)，選擇單(Single) ➢對於施工(Construction)，選擇簡單(Simple) 選擇“簡單”選項後，系統會嘗試構建最簡單的表面，使貼劑的數量最少。 \n ➢點擊確定 \n \n 7.2.4使用曲線和面建模 \n ➢打開freeform_thrucurves_faces.prt(曲線和面將顯示在右側) ➢選擇插入→網格表面→直通曲線(Through) ➢選擇頂面的邊1 ➢選擇edge-2並單擊MB2 ➢選擇邊3 ➢在介面對齊下，取消選中“保留形狀”檢查框 \n \n 確保所有箭頭都指向同一方向（如果不是，請雙擊任一箭頭即可翻轉其方向）。 ➢在對齊後於介面中選擇參數 ➢在“連續性”介面的“第一部分”中，選擇“ G2（曲率）”選項，然後選擇頂面的兩個斑塊 ➢點擊應用 \n \n 現在選擇edge-3，然後單擊MB2 ➢選擇下平面的三個邊緣 ➢在“第一部分”的“連續性”介面中將選項更改為G2（曲率） ➢選擇剛創建的表面，然後單擊MB2 ➢對於最後一節的連續性，選擇G2（曲率），然後選擇底部三個補丁作為參考 ➢單擊確定退出 \n \n \n 40723243\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0劉子源\xa0\xa0 \n NX繪圖模擬 :\xa0 \n 影片網址 :\xa0 https://youtu.be/9tC1mZya2_E \n \n \n 40723245\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0蔡育灃 \n NX12第9章－製造 \n 9.1開始 在將每個CAD模型移入模型之前，需要執行一些準備步驟。 CAM環境。在本章中，我們將使用在以前的運動問題。在此模型中，所有單位均以毫米為單位，並且組件的製造。在開始之前，如果可以成為CAM高級角色。為此，請轉到角色資源欄上的菜單。單擊內容和列表將彈出可供CAM Advanced角色使用的選項 9.1.1創建空白 ➢在第4章中打開文件Die_cavity.prt以解決運動問題 ➢要創建坯料，請插入以下尺寸的塊 長度= 150毫米 寬度= 100毫米 高度= 80毫米 ➢對於“原點”選項，選擇基本塊的最低角，以便新創建的塊可以包裝整個以前的模型，該塊包含整個設計部分，因此我們需要更改該塊的顯示屬性以獲得更好的可視化效果。 ➢單擊視圖選項卡的可視化組中的編輯對象顯示圖標 ➢選擇剛創建的塊，然後單擊確定。 ➢彈出窗口時，更改顯示顏色並將透明度更改為50 ➢點擊確定 ➢右鍵單擊零件瀏覽器中的塊，然後隱藏剛剛創建的塊。 單擊“隱藏”（可能需要使用“從列表中選擇...”來選擇空白）。這將使原始塊將從工作環境中消失。 9.1.2設置加工環境 現在我們準備進入製造模塊。 ➢選擇文件→新建→製造→銑削車削 ➢有許多不同的定制CAM模板可用於不同的加工 操作。在這裡，我們僅對銑削操作感興趣。 9.1.3操作導航器 ➢單擊資源欄左側的“操作導航器”選項卡 操作導航器提供有關已創建程序和相應程序的信息 有關刀具，方法和策略的信息。程序列表可以用不同的方式查看 分類列表。在“操作導航器”中有四種查看程序列表的方法， 它們是“程序順序”視圖，“機床”視圖，“幾何”視圖和“加工方法”視圖。 ➢單擊幾何視圖 9.1.4機器坐標系（MCS） ➢單擊插入組中的創建幾何圖標 啟動編程設置 將看到“創建幾何體”彈出對話框。 ➢點擊確定 另一個彈出窗口將允許設置MCS 哪裡都行。默認情況下，NX 12採用原始 絕對CS作為MCS。 ➢單擊確定選擇默認選項作為MCS 9.1.5幾何定義 ➢單擊幾何視圖 ➢通過在操作導航器中單擊“ +”號來展開MCS_MAIN_SPINDLE ➢在操作導航器中雙擊WORKPIECE_MAIN。如果看不到 嘗試點擊相關的“ +”號 彈出窗口Workpiece Main 出現。可以在此處分配 零件幾何，毛坯幾何和 檢查幾何。 ➢單擊零件圖標 ➢選擇設計部分，然後單擊 ➢單擊空白圖標 ➢單擊塊，然後按確定 ➢單擊確定退出工件主窗口 \n 9.2創建操作 \n 9.2.1創建新操作 ➢單擊工具欄中的創建操作圖標 彈出創建操作窗口。 ➢確保操作類型為Mill_Contour ➢單擊左上方的Cavity_Mill圖標，如下所示： ➢選擇程序為1234 ➢將幾何更改為WORKPIECE_MAIN ➢點擊確定 通過序列。 9.2.2工具創建和選擇 ➢在型腔銑削彈出菜單中，單擊“工具”對話框中的“新建”按鈕。 ➢點擊新建 ➢在新工具窗口中，選擇銑削圖標 ➢輸入BUEM12X1作為名稱並單擊 ➢輸入如下圖所示的值 ➢點擊確定 9.2.3工具路徑設置 確保“工具軸”垂直於塊的頂面。 ➢單擊工具軸，然後選擇指定向量 ➢如圖所示選擇合適的軸 ➢在腔銑刀菜單中，單擊路徑 設置選項 9.2.4跨步和扇貝高度 選擇了“跨步”選項。這些選項包括“常量”、“扇貝”， 工具直徑等。例如，“常數”要求輸入下一行的距離值。 扇貝高度根據最大高度控制平行通道之間的距離 指定在通過之間保留的材料（扇貝）。這受刀具定義的影響 和曲面的曲率。扇貝允許系統確定跨步距離 根據輸入的扇貝高度。 ➢對於Stepover，選擇％Tool Flat，然後將Percent更改為70 9.2.5每次切割深度 ➢將每次切割的通用深度值更改為0.5 ➢點擊削減水平 ➢將範圍類型更改為用戶定義 ➢將範圍深度更改為80 ➢選擇確定 9.2.6切削參數 ➢在路徑設置菜單上，單擊切割 ➢在策略選項卡按鈕下，更改剪切 ➢單擊股票選項卡 ➢將零件側庫存的值更改為0.5 ➢點擊確定 9.2.7迴避 ➢單擊非切割動作 ➢單擊迴避標籤 該窗口由以下幾個避免點組成： 我們關注以下幾點： 從起點這是換刀命令的關鍵點進行。該值通常是50或100 Z = 0高度以上mm，以增強安全性 自動工具更換切刀時的工作 轉換器（ATC）。 ➢點擊起點 ➢在點選項字段中選擇指定 ➢在點對話框中，輸入坐標 XC，YC和ZC為（0、0、50） ➢點擊確定 這是程序開始和結束的地方。該值也比 Z = 0級別可增強安全性。這也是機器操作員檢查高度的地方 相對於作業的Z = 0級別安裝在主軸上的刀具。此交叉檢查 在機床中輸入的刀具補償。 ➢單擊起點 ➢選擇指定 ➢在點對話框中輸入坐標（0，0，50） ➢單擊確定退出點構造器 ➢單擊轉移/快速選項卡 ➢在間隙選項中選擇平面 ➢從類型選項卡的下拉菜單中選擇XC-YC平面 ➢在偏移和參考標籤下，輸入 值3作為距離 ➢單擊兩次“確定”返回到腔磨機 參數窗口 9.2.8速度和進給 ➢選擇進給和速度輸入進給和速度參數 ➢輸入主軸轉速值為4500 rpm 單個程序中涉及許多feed。 最重要的是切削飼料。進給時，工具將與原始工件並實際上切掉材料工件。 它是相對線速度刀具相對於作業移動的位置。 其他提要是可選的。一些機器控制系統使用其默認的回退和移動進給。在在這些情況下，即使沒有輸入其他提要，就不會有任何問題。一些控制系統可能會從程序。它可能比機器的略小最大進給速度。 ➢輸入Cut值為1200 mmpm ➢點擊確定 \n 9.3程序生成和驗證 \n 9.3.1生成程序 現在我們完成了輸入所需的所有參數 用於粗加工程序。現在是時候生成 程序。 ➢單擊工具欄底部的“生成”圖標。 窗口 現在可以觀察對模型進行切片的軟件 切入深度並在每個級別上創建刀具路徑。 可以在模型上找到青色，藍色，紅色和黃色 如圖所示。 9.3.2刀具路徑顯示 每當想查看刀具的整個刀具路徑時 程序，在“操作”中右鍵單擊該程序 導航器，然後單擊重播。它將顯示為可以觀察到“操作導航器”中該程序的旁邊是黃色的驚嘆號而不是紅色標記。這意味著程序已成功生成，但尚未生成 經過後期處理。如果模型有任何更改，程序將再次帶有紅色標記在它的旁邊。這意味著必須再次生成程序。但是，沒有必要更改程序中的任何參數。 9.3.3刀具路徑模擬 檢查創建的程序非常重要。這樣可以防止任何不當和 在切割路徑中進行危險動作。錯誤的參數和設置將給工件造成高昂的損壞。為避免此類錯誤，NX 12提供工具路徑驗證和鑿檢查。刀具路徑驗證可用於查看整個程序中的刀具運動。可以觀察工具的嚙合方式以及切割後的縮回方式。它還顯示了實際材料通過圖形模擬刪除。還可以通過以下方式查看特定的關注區域移動程序行。 ➢在Operation Navigator中右鍵單擊該程序，然後選擇Tool Path→V陶醉 或單擊工具欄中的“驗證工具路徑”按鈕 這將允許設置用於可視化工具路徑的參數。 ➢在工具路徑可視化窗口中，單擊 在播放圖標上查看動作 還可以在不同模式下查看可視化 通過更改旁邊的下拉菜單中的選項 顯示。 ➢單擊同一頁面上的3D動態選項卡 窗口 ➢單擊同一頁面上的“顯示選項”按鈕 窗口 ➢將動作數更改為50 ➢將動畫精度更改為精細 ➢將IPW顏色更改為綠色 ➢點擊確定 ➢再次單擊播放按鈕 模擬將如下圖所示 正確的。使用此選項，將能夠查看 實際的切削模擬和材料去除 通過計算機圖形學。它是3D動態的 可以在模擬時旋轉，平移和縮放模擬 正在玩。 9.3.4鑿檢查 切屑檢查用於驗證刀具是否從工件上去除了零件幾何形狀上多餘的材料。考慮到設計公差，任何製造過程 可能通過兩種方式生產有缺陷的零件。一種是去除多餘的材料，也稱為 更少的材料條件。另一種是留下應該清除的材料 是更多的物質條件。在大多數情況下，前者更危險，因為不可能 重新設計部分。後者更安全，因為可以通過返工去除殘留的材料 那個部分。鑿檢查選項檢查 前一種情況是多餘的材料清除 將被識別。 ➢右鍵單擊操作中的程序 航海家 ➢選擇工具路徑→鑿檢查 ➢點擊確定 鑿檢查完成後，刀具路徑 報告窗口將彈出。如果有的話 找到鑿子，就要糾正程序。 除此以外， ➢單擊確定或直接關閉彈出窗口 \n 9.4操作方法 \n 9.4.1粗加工 對於銑削操作，在完成作業之前，首先應進行粗銑削。 粗加工的主要目的是以更快的速度去除散裝物料，而不會影響 準確性和工作完成度。給予庫存津貼以為生產提供足夠的材料。 完成操作以獲得準確和良好的完成工作。我們在上一部分中所做的 本章正在生成粗加工程序。現在我們必須適度消除所有不平整 上一個程序剩餘的材料。 9.4.2半精加工 半精加工程序旨在消除由於粗加工引起的不均勻 並為精加工工序保留部分庫存津貼。一旦我們完成了第一個 粗加工程序中，半精加工總是更容易執行。 現在，我們將第一個程序複製並粘貼到Operation Navigator中。在新程序中 只需要更改一些參數和切削刀具尺寸，然後重新生成 程序。 ➢右鍵單擊CAVITY_MILL程序 操作導航器，然後單擊複製 ➢再次右鍵單擊CAVITY_MILL，然後 選擇粘貼 ➢右鍵單擊第二個 剛創建的CAVITY_MILL_COPY，然後單擊重命名 ➢將第二個程序重命名為CAVITY_MILL_1 會看到新創建的CAVITY_MILL_1旁邊有一個紅色標記，表示 該程序未生成。 現在讓我們設置第二個程序需要更改的參數。在開始之前，我們 應該分析零件的幾何形狀以找出刀具直徑的最小角半徑。 在我們的模型中為5毫米，在地板邊緣為1毫米。因此，刀具直徑可以是 小於10毫米的任何物體。為了獲得最佳的輸出和剛性，我們將選擇帶有 直徑10，下半徑1。 ➢在Operation Navigator上雙擊CAVITY_MILL_1以打開參數 窗口 就像在上一個程序中一樣，我們將創建一個新刀具。在工具標籤中，將看到 首先選擇的刀具。它將顯示BUEM12X1作為當前工具。 ➢創建一個新的工廠並命名為BUEM10X1 ➢直徑應小於10 半徑為1，長笛長度為38 ➢點擊確定 ➢單擊每次切割的公共深度為0.25英寸 路徑設置 ➢然後單擊切割參數按鈕 ➢單擊股票選項卡 ➢取消選中與使用地板相同旁邊的框 側 ➢輸入0.25作為零件庫存 ➢輸入0.1作為零件底盤存貨 ➢單擊遏制選項卡按鈕 ➢在“在製品中”旁邊的下拉菜單中，選擇“使用3D”。 In Process Workpiece是NX中非常有用的選項。該軟件考慮了先前的程序 並生成當前程序，例如在無材料區域沒有不必要的切削運動。這種策略大大減少了切割時間和空氣切割運動。的 該算法將強制切刀僅去除之前的材料 計劃並保持當前零件庫存限額。 ➢選擇確定以返回到參數窗口 ➢單擊提要和速度 ➢輸入主軸轉速5000 ➢然後點擊確定 半成品程序的參數和設置完成。 ➢通過單擊生成圖標重新生成程序 ➢軟件生成完成後，單擊確定。 然後重播“工具路徑可視化”。第二個程序中生成的整體刀具路徑 如下圖所示。可以重播它或以類似方式檢查氣刨。 9.4.3整理概況 到目前為止，我們已經完成了零件的粗加工和半精加工程序。有一個小 工件中剩餘的材料量，可在精加工程序中去除，以獲得 所需的精確零件幾何形狀。整理程序應生成為 零件的表面應正確加工。因此，最好創建多個 程序以獨特的方式加工具有相關切削參數和策略的表面集，而不是 而不是為所有曲面編寫一個程序。以下內容說明瞭如何對配置文件進行分組和 表面並創建塗飾程序。 9.4.3.1外部輪廓 該程序旨在將外斜牆修整到地板的底部。因為 該程序不應觸摸頂部的輪廓表面，我們將進行“檢查並修剪” 程序中的邊界。 ➢重複與之前相同的步驟，在操作上複製並粘貼CAVITY_MILL_1 航海家 ➢重命名程序CAVITY_MILL_2 ➢雙擊CAVITY_MILL_2進行參數更改 ➢在彈出的參數窗口中，將“剪切樣式”更改為“輪廓”，然後將“步進”更改為 佔40％ ➢單擊指定修剪邊界選項卡 修剪邊界窗口將彈出。確保 在右邊執行以下步驟 序列。保持Trim Side的默認設置為 內。這告訴軟件切刀不應 在邊界內的任何地方切割材料。修剪允許 可以指定邊界，以進一步限制每個切割級別的切割區域。 ➢將選擇方法更改為曲線 ➢將平面從自動更改為指定，然後單擊平面對話框 將會彈出一個新窗口。窗口將詢問選擇飛機的模式 曲線應投影。通常應該在零件的最高點 幾何。準確地說，它應該在MCS上。 ➢從類型下的下拉菜單中選擇XC-YC平面 ➢在距離旁邊輸入3 ➢點擊確定 現在我們將開始從零件中選擇邊。這些選定的邊將投影在Z = 3平面作為曲線並用作邊界。 ➢如圖所示，沿著輪廓表面選擇牆的所有頂部外邊緣。 確保連續選擇所有8條邊線 ➢選擇確定 ➢輸入每次切割的通用深度為0.2 ➢點擊切割參數 ➢在彈出對話框中，單擊“股票”選項卡 ➢輸入零件側面庫存和零件底面庫存值為0.00 Intol允許指定最大距離 切割器可能偏離預期的路徑進入 工件。 Outtol允許指定最大距離 刀具可能會偏離預期的路徑而遠離 工件。 ➢輸入Intol和Outtol值為0.001 如圖所示 ➢點擊確定 ➢單擊生成圖標以生成 主參數窗口中的程序 ➢當 程序生成完成 外部輪廓的精加工程序現已準備就緒。可以在重放工具時觀察 切刀永遠不會越過為修剪和檢查所給定邊界的路徑。切刀 縮回Z = 3平面以進行重定位。 9.4.3.2內部輪廓 ➢重複與之前相同的步驟，在操作上複製並粘貼CAVITY_MILL_2 導航器並將其重命名為CAVITY_MILL_3 ➢雙擊CAVITY_MILL_3以編輯參數或右鍵單擊它並選擇Edit ➢選擇“指定修剪邊界”選項卡，然後在彈出窗口中選擇“修剪邊在外部” 對話框 這樣可以防止切刀通過邊界。 ➢將選擇方法更改為曲線 ➢手動將平面更改為XC-YC平面，並將偏移距離輸入為3 ➢點擊確定 ➢如圖所示，選擇沿輪廓表面的所有頂部內邊緣。再次，使 確保所有8條邊都被選中以連續的順序（使用Shift +單擊以取消選擇曲線）。 ➢選擇確定返回參數窗口 ➢生成程序 ➢生成完成後，單擊確定。 內部輪廓的精加工程序現已準備就緒。通過重播工具路徑，可以 觀察到切刀永遠不會越過修剪和檢查所給定的邊界。 9.4.4修整輪廓表面 現在，我們將使用其他類型的策略來完成頂部自由曲面。 ➢單擊工具欄中的創建操作圖標 ➢單擊固定輪廓圖標為 如圖所示 ➢選擇1234作為程序 ➢選擇WORKPIECE_MAIN作為 幾何 ➢保留程序的默認名稱 ➢點擊確定 ➢在參數窗口的驅動方法下，確保已選擇邊界 ➢單擊圖標，這將彈出“邊界驅動方法”窗口，然後單擊 如圖所示，打開“邊界幾何”菜單 ➢將模式更改為曲線/邊線 ➢選擇材料面在外面 ➢選擇工具位置為開 工具位置確定工具在接近邊界時如何定位自身 會員。可以為邊界成員分配三個工具位置之一：“打開”，“ Tanto”或“接觸”。 •在“打開”位置，工具的中心點與沿工具軸的邊界對齊或 投影向量。 •在Tanto位置，工具的側面與邊界對齊。 •在“接觸”位置，工具接觸邊界。 ➢對於飛機，選擇“用戶定義” ➢再次將平面設置為XC-YC，距離為3 ➢點擊確定 ➢如圖所示，選擇頂部輪廓表面的外環。記得選擇 邊緣連續 ➢點擊確定 我們已在循環外部修剪了幾何圖形。現在我們必須修剪內部的幾何 內部循環，這樣剩下的唯一幾何圖形就是兩個循環之間的區域。 ➢選擇模式為曲線/邊線 ➢選擇材料面為內側，工具位置為開 ➢在XC-YC上選擇用戶定義的平面，距離為3 ➢如圖所示選擇輪廓表面的內邊緣 ➢單擊確定返回到邊界驅動方法窗口 ➢將Stepover方法更改為Scallop，輸入高度為0.001，然後單擊OK。 ➢點擊切割參數 ➢在庫存選項卡中更改容差值，以便 零件總和零件總和是0.001 ➢單擊更多選項卡按鈕並輸入值 最大步長為1.0 ➢點擊確定 在主要參數窗口中， ➢創建一個新工具並將其命名為BEM10 ➢將直徑更改為10毫米或更小 半徑為5毫米。 ➢點擊確定 ➢單擊工具欄上的Feeds and Speeds圖標。 參數窗口 ➢輸入主軸轉速，進給速度（切削）和 如圖所示計算其他 對 ➢點擊確定 ➢生成程序 輪廓表面現已完成，可以查看 通過刀具路徑驗證進行仿真。 9.4.5地板 地板是在地板上執行的整理操作 零件的水平平面（地板）。在大多數 銑削過程中，地板將是最終的 他們的運作。所有的水平面將 完成。這種平面操作使切刀在 每張臉都單次通過。 ➢單擊創建操作圖標 ➢在頂部將類型更改為mill_planar 窗戶的 ➢更改所有選項，如圖所示 ➢點擊確定 ➢在參數窗口中，更改剪切 跟隨模式 ➢更改以下刀具直徑的百分比 步入40 在地板操作中，最好始終保持 步進值小於直徑的一半 刀具以在平面上獲得更大的平整度 表面。 與以前的程序不同，我們必須選擇一個剪切區域。 ➢單擊“指定切割區域地板”，如圖所示 ➢選擇顯示在 下圖 如果無法選擇如圖所示的表面 轉到零件導航器並隱藏空白（選擇 空白，可以右鍵單擊空白，使用選擇 列表...），選擇曲面並再次取消隱藏毛坯。 ➢點擊確定 ➢在主參數窗口中單擊切割參數 ➢選擇庫存選項卡按鈕並輸入Intol和Outtol值為0.001 ➢點擊確定 ➢單擊提要和速度 在“參數”主窗口中， ➢創建一個新工具並將其命名為BEF105 ➢將直徑更改為10毫米或更小 半徑為5毫米 ➢點擊確定 因為這是地板操作，所以最好將主軸轉速高，進給速度低 到以前的操作。 ➢輸入主軸速度，進給速度的值 （剪切）併計算其他值，如 數字 ➢選擇確定 ➢生成程序。然後重播並驗證 切刀路徑 下圖顯示了地板的“刀具路徑”顯示。 9.5後期處理 製造應用程序的主要用途是生成製造的工具路徑 部分。通常，我們不能僅將未修改的刀具路徑文件發送到機器並開始切割 因為有許多不同類型的機器。每種機器都有獨特的硬件 功能，要求和控制系統。例如，機器可能具有垂直或垂直 臥式主軸它可以在同時移動多個軸的同時進行切割等。控制器接受 工具路徑文件，並指示工具運動和其他機器活動（例如轉動冷卻液或 空氣）。 自然，每種類型的機器都有獨特的硬件特性；控制器在以下方面也有所不同 軟件特性。例如，大多數控制器都要求將 冷卻液在特定代碼中給出。一些控制器還限制了M代碼的數量， 在一行輸出中被允許。此類信息不在最初的NX工具路徑中。 因此，必須修改刀具路徑以適合每種不同的獨特參數。 機器/控制器組合。修改過程稱為後處理。結果是 後處理的刀具路徑。 生成最終的後加工刀具路徑涉及兩個步驟。 1.創建刀具路徑數據文件，或稱為CLSF（刀具位置源文件）。 2.將CLSF後處理為機器CNC代碼（後處理文件）。該程序讀取 工具路徑數據並將其重新格式化以用於特定機器及其隨附工具 控制器。 9.5.1創建CLSF 生成並保存操作後，將生成的刀具路徑存儲為操作的一部分 在零件文件中。 CLSF（刀具位置源文件）提供了複製這些內部文件的方法 從零件文件中的操作到CLSF中的工具路徑（即文本文件）的路徑。的 GOTO值是當前刀具路徑的“快照”。導出的值引用自 操作中存儲的MCS。 CLS文件是某些後續程序的必需輸入， 例如後處理器。 ➢單擊以下程序之一 想在 操作導航器 ➢點擊輸出CLSF 操作工具欄 將會彈出一個窗口以選擇CLSF 格式。 ➢選擇CLSF_STANDARD並 輸入文件的位置 ➢選擇確定 將創建CLSF文件。會類似於圖 下面。文件內容包含刀具的基本代碼 運動，沒有任何有關機器代碼和控制的信息 系統。該文件可用於任何機器的後處理 控制。文件的擴展名是.cls。 已輸出到CLSF或後處理的任何程序的下一個綠色複選標記 在“操作導航器”中對其進行操作。 9.5.2後處理 ➢在操作導航器中單擊要發布的程序 ➢單擊菜單→工具→操作導航器→輸出→後處理或從 主頁選項卡，如圖所示 ➢選擇MILL_3_AXIS機器並 輸入文件的位置 ➢選擇確定 這將為目標計算機創建後處理文件。可以找到塊號 帶有與機器控制器類型有關的G和M代碼。文件的擴展名是.ptp。 最終輸出（filename.ptp）文件可以傳輸到用於進行實際銑削的機器 操作。從模型轉移到製造開始的整個過程 模塊將文件傳輸到機器，並將原始零件加工成最終零件 被稱為計算機輔助製造 \n Webots 與 V-rep Tutorial操作： \n 40723201\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 吳沛汶 \n \n 40723204\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0 邱倚瀅 \n webots tutroial 1\xa0 https://youtu.be/Syi3X1j469Q \n \n \n 40723213\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0杜玗宸 \n \n 40723215\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0杜彥霆 \n \n 40723218\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0林志豪 \n \n 40723219\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0林承治 \n \n 40723237\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0黃俊翔\xa0 \n \n 40723242\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0趙子德 \n Webots\xa0 Tutorial \n Tutorial1: \n 1.建立場景 \n 2.設定場景參數 \n 3.新增物件並設定物件參數,並複製三個 \n 4.新增機器人並施加拉力測試 \n 5.將程式導入機器人路徑 \n 6.完成 \n \n tutorial2 : \n 1.刪去原有場景 \n 2.建立新樓板.圍牆及球 \n \n tutorial3 : \n 1.更改圍牆顏色及球體皮面 \n \n tutorial4 : \n 1.理解機器人路徑城市的編輯模式後,將路徑程式做更改 \n 2.機器人將自動迴避障礙物 \n \n tutorial5 : \n 1.將所有物件刪除只留場景 \n 2.新增啞鈴 \n \n Vrep\xa0 Tutorial: \n \n \n \n 40723243\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0劉子源\xa0\xa0 \n \n 40723245\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0蔡育灃 \n Webots Tutorial 1 操作影片 \n 1.一開始先點start_webots.bat開啟webots \n 2.創立新世界並改名成my_first_simulation \n 3.再來設定一些東西(詳情如以下影片查看) \n 4.建立木箱並設定尺寸、位置 \n 5.新增一個E-puck robot(電子冰球機器人) \n 6.測試物理施力會對木箱或機器人有什麼反應 \n 7.導入程式碼讓機器人照著程式走 \n \n', 'tags': '', 'url': 'week12.html'}, {'title': 'week13', 'text': '分組簡報 \n 40723201\xa0 \xa0 \xa0 \xa0 \xa0 吳沛汶 \n 40723204\xa0 \xa0 \xa0 \xa0 \xa0 邱倚瀅 \n 簡報  https://youtu.be/rOYvSCGnyHE \n \n 40723213\xa0 \xa0 \xa0 \xa0 \xa0 杜玗宸 \n 40723215\xa0 \xa0 \xa0 \xa0 \xa0 杜彥霆 \n 40723218\xa0 \xa0 \xa0 \xa0 \xa0 林志豪 \n 簡報\xa0 https://www.youtube.com/watch?v=zbnqAg080c8 \n \n 40723219\xa0 \xa0 \xa0 \xa0 \xa0 林承治 \n 40723237\xa0 \xa0 \xa0 \xa0 \xa0 黃俊翔 \n 簡報 \xa0 \xa0 https://www.youtube.com/watch?v=YUcpUfjFbu0 \n \n 40723242\xa0 \xa0 \xa0 \xa0 \xa0 趙子德 \n 簡報\xa0 https://s40723242.github.io/cad2019/reveal/index.html#/ \n \n 40723243\xa0 \xa0 \xa0 \xa0 \xa0 劉子源 \n 簡報\xa0 https://www.youtube.com/watch?v=HHE8XSvZRXU&feature=emb_title \n \n 40723245\xa0 \xa0 \xa0 \xa0 \xa0 蔡育灃 \n reveal報告\xa0 https://www.youtube.com/watch?v=VO4bPbI6ZxQ&feature=emb_logo \n \n', 'tags': '', 'url': 'week13.html'}, {'title': 'week15 - 18', 'text': '', 'tags': '', 'url': 'week15 - 18.html'}, {'title': 'week17協同任務', 'text': 'Building a clean model tutorial \n 40723201\xa0 \xa0 \xa0 \xa0 \xa0 吳沛汶 \n 40723204\xa0 \xa0 \xa0 \xa0 \xa0 邱倚瀅 \n The second important step is to export the original data with a limited precision: most CAD applications let you specify the level of details of exported meshes. It might also be important to export the objects in several steps, when the drawing consists of large and small objects; this is to avoid having large objects too precisely defined (too many triangles) and small objects too roughly defined (too few triangles): simply export large objects first (by adjusting the desired precision settings), then small objects (by adjusting up precision settings). \n 第二個重要步驟是以有限的精度導出原始數據：大多數CAD應用程式都允許指定導出的網格的細節級別。當工程圖由大小項目組成時，分幾步導出也很重要。這是為了避免大項目定義太精確（三角形太多）和小項目定義太粗糙（三角形太少）：首先簡單地導出大項目（通過調整所需的精度設置），然後導出小項目（通過調整精度設置） 。 \n \xa0CoppeliaSim supports currently following CAD data formats:\xa0 OBJ ,\xa0 STL ,\xa0 DXF ,\xa0 3DS \xa0(Windows only), and\xa0 Collada .\xa0 URDF \xa0is also supported, but not mentionned here since it is not a pure mesh-based file format. \n CoppeliaSim目前支援以下CAD格式：OBJ，STL，DXF，3DS（僅Windows）和Collada。另外還支援URDF，但此處未提及，因為它不是純網格的文件格式 \n Now suppose that we have applied all possible simplifications as described in previous section. We might still end-up with a too heavy mesh after import: \n 現在，假設我們已按照上一節中所述應用了所有可能的簡化。導入後，我們可能最終仍然會留下一個過重的網格： \n \xa0You can notice that the whole robot was imported as a single mesh. We will see later how to divide it appropriately. Notice also the wrong orientation of the imported mesh: best is to keep the orientation as it is, until the whole model was built, since, if at a later stage we want to import other items that are related to that same robot, they will automatically have the correct position/orientation relative to the original mesh. \n 這裡會注意到整個機器人是作為單個網格導入的。稍後將看到如何對此機器人進行適當劃分。要注意導入的網格的方向是否錯誤：最好保持其方向不變，直到建完整個模型為止，因為如果在後面的階段中要導入與此機器人相關的其他項目，它們將自動具有相對於原始網格的正確位置/方向。 \n \xa0At this stage, we have several functions at our disposal, to simplify the mesh: \n 在此階段，可以使用多種功能來簡化網格： \n Automatic mesh division: allows to generate a new shape for all elements that are not linked together via a common edge. This does not always work for the selected mesh, but is always worth a try, since working on mesh elements gives us more control than if we had to work on all elements at the same time. The function can be accessed with [Menu bar --> Edit --> Grouping/Merging --> Divide selected shapes]. Sometimes, a mesh will be divided more than expected. In that case, simply merge elements that logically belong together (i.e. that will have the same visual attributes and that are part of the same link) back into one single shape ([Menu bar --> Edit -> Grouping/Merging --> Merge selected shapes]). \n 自動網格劃分：允許為未通過公共邊鏈接在一起的所有元素生成新形狀。這並不總是適用於選定的網格，但是總是值得一試的，因為與必須同時處理所有元素相比，處理網格元素可以為我們提供更多的控制權。可以通過[菜單欄->編輯->分組/合併->分割所選形狀]訪問該功能。有時，網格劃分會超出預期。在這種情況下，只需將邏輯上屬於一起的元素（即，具有相同的視覺屬性並且屬於同一鏈接的一部分）合併回一個單一形狀（[菜單欄->編輯->分組/合併->合併選定的形狀]）。 \n \xa0 Extract the convex hull: allows to simplify the mesh by transforming it into a convex hull. The function can be accessed with [Menu bar --> Edit --> Morph selection into convex shapes]. \n 提取凸包：通過將其轉換為凸包來簡化網格。可以通過[菜單欄->編輯->將選擇變形為凸形]來訪問該功能 \n \xa0 Decimate the mesh: allows to reduce the number of triangles contained in the mesh. The function can be accessed with [Menu bar --> Edit --> Decimate selected shape...]. \n 抽取網格：減少網格中包含的三角形數量。可以通過[菜單欄->編輯->縮小所選形狀...]訪問該功能。 \n \xa0 Remove the inside of the mesh: allows to simplify the mesh by removing its inside. This function is based on\xa0 vision sensors \xa0and might give more or less satisfying results depending on the selected settings. The function can be accessed with [Menu bar --> Edit --> Extract inside of selected shape]. \n 刪除網格的內部：允許通過刪除其內部來簡化網格。此功能基於視覺傳感器，根據所選設置可能會或多或少地令人滿意。可以通過[菜單欄->編輯->提取選定形狀的內部]訪問該功能。 \n There is no predefined order in which above functions can/should be applied (except for the first item in the list, which should always be tried first), it heavily depends on the geometry of the mesh we are trying to simplify. Following image illustrates above functions applied to the imported mesh (let\'s suppose the first item in the list didn\'t work for us): \n 此處沒有可以應用上述功能的預定義順序（列表中的第一項除外，應始終首先嘗試該項），它在很大程度上取決於我們要簡化的網格的幾何形狀。下圖說明了應用於導入的網格的上述功能（假設列表中的第一項對我們不起作用）： \n \xa0Notice how the convex hull doesn\'t help us at this stage. We decide to use the mesh decimation function first, and run the function twice in order to divide the number of triangles by a total of 50. Once that is done, we extract the inside of the simplified shape and discard it. We end-up with a mesh containing a total of 2\'660 triangles (the original imported mesh contained more than 136\'000 triangles!). The number of triangles/vertices a shape contains can be seen in the\xa0 shape geometry dialog . 2\'660 triangles are extremely few triangles for a whole robot model, and the visual appearance might suffer a little bit from it. \n 請注意，凸包在現階段如何對我們沒有幫助。我們決定首先使用網格抽取功能，然後運行兩次該功能，以將三角形的數量總共除以50。完成後，我們提取簡化形狀的內部並將其丟棄。我們最終得到的網格總共包含2\'660個三角形（原始導入的網格包含了136\'000個三角形！）。形狀包含的三角形/頂點的數量可以在形狀幾何對話框中看到。對於整個機器人模型，2\'660三角形是極少的三角形，因此視覺外觀可能會因此受到影響。 \n \xa0 \n 40723213\xa0 \xa0 \xa0 \xa0 \xa0 杜玗宸 \n 翻譯 Building a clean model tutorial \n At this stage we can start to divide the robot into separate links (remember, we \n currently have only a single shape for the whole robot). You can do this in two different ways: \n 在這一階段，我們可以開始將機器人劃分為單獨的鏈接（請記住， \n 目前整個機器人只有一個形狀）。 您可以通過兩種不同的方式執行此操作： \n \n Automatic mesh division: this function, which was already described in previous section, will inspect the shape and generate a new shape for all elements that are not linked together via a common edge. This does not always work, but is always worth a try. The function can be accessed with [Menu bar --> Edit --> Grouping/merging --> Divide selected shapes]. \n 自動網格劃分：上一小節已經描述了此功能，它將檢查形狀並為未通過公共邊鏈接在一起的所有元素生成新形狀。 這並不總是有效，但總是值得嘗試的。 可以通過 [ 菜單欄 -> 編輯 -> 分組 / 合併 -> 分割所選形狀 ] 訪問該功能。 \n Manual mesh division: via the the\xa0 triangle edit mode , you can manually select the triangles than logically belong together, then click\xa0 Extract shape . This will generate a new shape in the scene. Delete the selected triangles after that operation. \n 手動網格劃分：通過三角形編輯模式，您可以手動選擇邏輯上不屬於邏輯的三角形，然後單擊“提取形狀”。 這將在場景中生成新形狀。 完成該操作後，刪除選定的三角形。 \n \n In the case of our mesh, method 1 worked fine: \n 對於我們的網格，方法1可以正常工作： \n \n [Divided mesh] \n \n Now, we could further refine/simplify individual shapes. Sometimes also, a shape might look better if its convex hull is used instead. Othertimes, you will have to use several of above\'s described techniques iteratively, in order to obtain the desired result. Take for instance following mesh: \n 現在，我們可以進一步細化/簡化單個形狀。 有時，如果改用凸包，形狀可能會看起來更好。 有時，您將不得不反複使用上述幾種技術，以獲得所需的結果。 以以下網格為例： \n \n [Imported mesh] \n \n The problem with above\'s shape is that we cannot simplify it nicely, because of the holes it contains. So we have to go the more complicated way via the\xa0 shape edit mode , where we can extract individual elements that logically belong to the same convex sub-entity. This process can take several iterations: we first extract 3 approximate convex elements. For now, we ignore the triangles that are part of the two holes. While editing a shape in the shape edit mode, it can be convenient to switch the\xa0 visibility layers , in order to see what is covered by other scene items. \n 上面形狀的問題是，由於其中包含孔，我們無法很好地簡化它。 因此，我們必須通過形狀編輯模式進行更複雜的處理，在該模式下，我們可以提取邏輯上屬於同一凸形子實體的單個元素。 此過程可能需要進行多次迭代：我們首先提取3個近似凸元素。 現在，我們忽略作為兩個孔的一部分的三角形。 在形狀編輯模式下編輯形狀時，可以方便地切換可見性圖層，以查看其他場景項所覆蓋的內容。 \n \n [Step 1] \n \n We end up with a toal of three shapes, but two of them will need further improvement. Now we can erase the triangles that are part of the holes. Finally, we extract the convex hull individually for the 3 shapes, then merge them back together with [Menu bar --> Edit --> Grouping/Merging --> merge selected shapes]: \n 我們最終得到三個形狀的總和，但是其中兩個將需要進一步改進。 現在我們可以擦除作為孔的一部分的三角形。 最後，我們分別提取3種形狀的凸包，然後將其與[菜單欄->編輯->分組/合併->合併所選形狀]合併在一起： \n \xa0 \n [Step 2] \n \n In CoppeliaSim, we can enable/disable edge display for each shape. We can also specify an angle that will be taken into account for the edge display. A similar parameter is the\xa0 shading angle , that dictates how facetted the shape will display. Those parameters, and a few others such as the shape\xa0 color , can be adjusted in the\xa0 shape properties . Remember that\xa0 shapes come in various flavours . In this tutorial we have only dealt with simple shapes up to now: a simple shape has a single set of visual attributes (i.e. one color, one shading angle, etc.). If you merge two shapes, then the result will be a simple shape. You can also group shapes, in which case, each shape will retain its visual attributes. \n In next step, we can merge elements that logically belong together (if they are part of the same rigid element, and if they have the same visual attributes). Then we change the visual attributes of the various elements. The easiest ist to adjust a few shapes that have different colors and visual attributes, and if we name the color with a specific string, we can later easily programmatically change that color, also if the shape is part of a compound shape. Then, we select all the shapes that have the same visual attributes, then control-select the shape that was already adjusted, then click\xa0 Apply to selection , once for the\xa0 Colors , once for the\xa0 other properties , in the\xa0 shape properties : this transfers all visual attributes to the selected shapes (including the color name if you provided one).\xa0 \n 在CoppeliaSim中，我們可以啟用/禁用每種形狀的邊緣顯示。我們還可以指定邊緣顯示時要考慮的角度。相似的參數是陰影角，它指示形狀將在多方面顯示。這些參數以及其他一些參數（例如形狀顏色）可以在形狀屬性中進行調整。請記住，形狀有多種風味。到目前為止，在本教程中，我們僅處理簡單的形狀：簡單的形狀具有一組視覺屬性（即一種顏色，一個陰影角度等）。如果合併兩個形狀，則結果將是一個簡單的形狀。您還可以對形狀進行分組，在這種情況下，每個形狀將保留其視覺屬性。 \n 在下一步中，我們可以合併邏輯上屬於一起的元素（如果它們屬於同一剛性元素，並且具有相同的視覺屬性）。然後，我們更改各種元素的視覺屬性。調整具有不同顏色和視覺屬性的幾種形狀的最簡便方法，如果我們使用特定的字符串來命名顏色，則以後可以輕鬆地以編程方式更改該顏色，即使該形狀是複合形狀的一部分。然後，我們選擇所有具有相同視覺屬性的形狀，然後控制選擇已調整的形狀，然後單擊“應用於選擇”，一次是“顏色”，一次是其他屬性，在形狀屬性中：這將轉移所有所選形狀的視覺屬性（如果提供的話，還包括顏色名稱）。 \n 40723215\xa0 \xa0 \xa0 \xa0 \xa0 杜彥霆 \n 40723218\xa0 \xa0 \xa0 \xa0 \xa0 林志豪 \n We end up with 17 individual shapes: \n 我們最終得到17個單獨的形狀： \n \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0[Adjusted visual attributes] \n [調整後的視覺屬性] \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \n Now we can group the shapes that are part of the same link with [Menu bar --> Edit --> Grouping/merging -> Group selected shapes]. We end up with 7 shapes: the base of the robot (or base of the robot\'s hierarchy tree), and 6 mobile links. It is also important to correctly name your objects: you we do this with a double-click on the object name in the\xa0 scene hierarchy . The base should always be the robot or model name, and the other objects should always contain the base object name, like:\xa0 robot \xa0(base),\xa0 robot_link1 ,\xa0 robot_proximitySensor , etc. By defaut, shapes will be assigned to visibility layer 1, but can be changed in the\xa0 object common properties . By default, only\xa0 visibility layers 1-8 are activated for the scene . We now have following (the model\xa0 ResizableFloor_5_25 \xa0was temporarily made invisible in the\xa0 model properties dialog ): \n 現在，我們可以使用[菜單欄->編輯->分組/合併->分組所選形狀]對屬於同一鏈接的形狀進行分組。 我們最終得到7個形狀：機器人的基礎（或機器人的層次結構樹的基礎）和6個移動鏈接。 正確命名對像也很重要：您可以通過雙擊場景層次結構中的對象名稱來做到這一點。 基礎應始終是機械手或模型名稱，其他對象應始終包含基礎對象名稱，例如：robot（基礎），robot_link1，robot_proximitySensor等。通過默認，形狀將分配給可見性層1，但可以 在對象通用屬性中進行更改。 默認情況下，僅激活場景的可見性層1-8。 現在，我們有了以下內容（模型ResizableFloor_5_25模型在模型屬性對話框中暫時不可見）： \n \n [Individual elements compositn the robot] \n [構成機器人的各個要素] \n When a shape is created or modified, CoppeliaSim will automatically set its reference frame position and orientation. A shape\'s reference frame will always be positioned at the shape\'s geometric center. The frame orientation will be selected so that the shape\'s bounding box remains as small as possible. This does not always look nice, but we can always reorient a shape\'s reference frame at any time. We now reorient the reference frames of all our created shapes with [Menu bar --> Edit --> Reorient bounding box --> with reference frame of world]. You have more options to reorient a reference frame in the shape geometry dialog. \n 創建或修改形狀時，CoppeliaSim將自動設置其參考框架的位置和方向。 形狀的參考框架將始終位於形狀的幾何中心。 將選擇框架方向，以便形狀的邊界框保持盡可能小。 這並不總是看起來不錯，但是我們隨時可以隨時調整形狀的參考框架的方向。 現在，我們可以使用[菜單欄->編輯->重定向邊界框->使用世界參考框架]重新調整所有已創建形狀的參考框架。 您有更多選項可以在形狀幾何對話框中重新定向參考框架。 \n Building the joints Now we will take care of the joints/motors. Most of the time, we know the exact position and orientation of each of the joints. In that case, we simply add the joints with [Menu bar --> Add --> Joints --> ...], then we can change their position and orientation with the position dialog and orientation dialog. In other situations, we only have the Denavit-Hartenberg (i.e. D-H) parameters. In that case, we can build our joints via the tool model located in Models/tools/Denavit-Hartenberg joint creator.ttm, in the model browser. Othertimes, we have no information about the joint locations and orientations. Then, we need to extract them from the imported mesh. Let\'s suppose this is our case. Instead of working on the modified, more approximate mesh, we open a new scene, and import the original CAD data again. Most of the time, we can extract meshes or primitive shapes from the original mesh. The first step is to subdivide the original mesh. If that does not work, we do it via the triangle edit mode. Let\'s suppose that we could divide the original mesh. We now have smaller objects that we can inspect. We are looking for revolute shapes, that could be used as reference to create joints at their locations, with the same orientation. First, remove all objects that are not needed. It is sometimes also useful to work across several opened scenes, for easier visualization/manipulation. In our case, we focus first on the base of the robot: it contains a cylinder that has the correct position for the first joint. In the triangle edit mode, we have: \n 建立關節 現在，我們將照顧關節/馬達。大多數時候，我們知道每個關節的確切位置和方向。在這種情況下，我們只需使用[菜單欄->添加->關節-> ...]添加關節，然後可以使用位置對話框和方向對話框更改它們的位置和方向。在其他情況下，我們只有Denavit-Hartenberg（即D-H）參數。在這種情況下，我們可以通過模型瀏覽器中位於Models / tools / Denavit-Hartenberg聯合creator.ttm中的工具模型來構建關節。有時，我們沒有關於關節位置和方向的信息。然後，我們需要從導入的網格中提取它們。讓我們假設這是我們的情況。無需處理修改過的，更近似的網格，而是打開一個新場景，然後再次導入原始CAD數據。大多數時候，我們可以從原始網格中提取網格或基本形狀。第一步是細分原始網格。如果那不起作用，我們將通過三角形編輯模式進行操作。假設我們可以劃分原始網格。現在，我們可以檢查較小的對象。我們正在尋找旋轉形狀，可以用作在其位置以相同方向創建關節的參考。首先，刪除所有不需要的對象。有時在多個打開的場景中工作也很有用，以便於可視化/操作。在我們的案例中，我們首先關注機器人的基座：它包含一個圓柱體，該圓柱體的第一個關節的位置正確。在三角形編輯模式下，我們有： \n \n [Robot base: normal and triangle edit mode visualization] \n [機器人基礎：法線和三角形編輯模式可視化] \n 40723219\xa0 \xa0 \xa0 \xa0 \xa0 林承治 \n 40723237\xa0 \xa0 \xa0 \xa0 \xa0 黃俊翔 \n \n respondable or non-respondable : a respondable shape will cause a collision reaction with other respondable shapes. They (and/or) their collider, will be influenced in their movement if they are dynamic. On the other hand, non-respondable shapes will not compute a collision response if they collide with other shapes. \n \n \xa0 \n \n 可回應或不可回應 ：回應形狀會導致與其他可回應形狀發生碰撞反應。它們（和/或）碰撞器，如果他們是動態的，就會影響它們的運動。另一方面，如果不可回應的形狀與其他形狀碰撞，則它們不會計算碰撞回應。 \n \n Above two points are illustrated\xa0 here . Respondable shapes should be as simple as possible, in order to allow for a fast and stable simulation. A physics engine will be able to simulate following 5 types of shapes with various degrees of speed and stability: \n \xa0 \n 上圖所示。回應形狀應盡可能簡單，以便快速、穩定地模擬。物理引擎將能夠類比以下 5 種具有不同速度和穩定性的形狀： \n \n Pure shapes : a pure shape will be stable and handled very efficiently by the physics engine. The draw-back is that pure shapes are limited in geometry: mostly cuboids, cylinders and spheres. If possible, use those for items that are in contact with other items for a longer time (e.g. the feet of a humanoid robot, the base of a serial manipulator, the fingers of a gripper, etc.). Pure shapes can be created with [Menu bar --> Add --> Primitive shape]. \n \n \xa0 \n \n 純形狀 ： 純形狀將穩定，物理引擎處理效率很高。回拉是純形狀在幾何中是有限的：主要是立方體、圓柱體和球體。如果可能，將這些物品用於與其他物品接觸更長時間的物品（例如類人機器人的腳、串列操縱器的底座、夾持器的手指等）。可以使用 [功能表列 -- > 添加 -gt; 原始形狀]創建純形狀。 \n \n \xa0 \n \n Pure compound shapes : a pure compound shape is a grouping of several pure shapes. It performs almost as well as pure shapes and shares similar properties. Pure compound shapes can be generated by grouping several pure shapes [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]. \n \n \xa0 \n \n 純複合形狀 ： 純複合形狀是幾個純形狀的組合。它的性能幾乎與純形狀相同，並且具有相似的屬性。純複合形狀可以通過分組多個純形狀生成  [ 功能表條 -- > 編輯 --> 分組/合併 -- > 組選定形狀]。 \n \n \xa0 \n \n Convex shapes : a convex shape will be a little bit less stable and take a little bit more computation time when handled by the physics engine. It allows for a more general geometry (only requirement: it need to be convex) than pure shapes. If possible, use convex shapes for items that are sporadically in contact with other items (e.g. the various links of a robot). Convex shapes can be generated with [Menu bar --> Add --> Convex hull of selection] or with [Menu bar --> Edit --> Morph selection into convex shapes]. \n \n \xa0 \n \n 凸形形狀 ：當物理引擎處理時，凸形狀會稍微不穩定一點，並且需要多一點的計算時間。它允許更一般的幾何形狀（僅要求：它需要凸）而不是純形狀。如果可能，對偶爾與其他專案接觸的專案（例如機器人的各種連結）使用凸形形狀。可以使用 [功能表列 -- > 添加 --gt; 選擇的凸包]或使用 [功能表列 -- > 編輯 --> 將選擇轉換為凸形形狀]生成凸形形狀。 \n \n \xa0 \n \n Compound convex shapes, or convex decomposed shapes : a convex decomposed shape is a grouping of several convex shapes. It performs almost as well as convex shapes and shares similar properties. Convex decomposed shapes can be generated by grouping several convex shapes [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes], with [Menu bar --> Add --> Convex decomposition of selection...], or with [Menu bar --> Edit --> Morph selection into its convex decomposition...]. \n \n \xa0 \n \n 複合凸形或凸分解形狀 ：凸分解形狀是多個凸形形狀的分組。它的性能幾乎與凸形狀一樣好，並且具有類似的屬性。可以通過對多個凸形形狀進行分組[功能表條 --> 編輯 -- > 分組/合併 -- > 組選定形狀]生成，使用 [功能表列 -- > 添加 --> 選擇的凸分解...]，或者使用 [功能表列 -- > 編輯 -- > 變形選擇到其凸分解中...]。 \n \n \xa0 \n \n Random shapes : a random shape is a shape that is not convex nor pure. It generally has poor performance (calculation speed and stability). Avoid using random shapes as much as possible. \n \n \xa0 \n \n 隨機形狀 ：隨機形狀是不凸或純的形狀。它的性能通常較差（計算速度和穩定性）。儘量避免使用隨機形狀。 \n \n \xa0 \n So the order of preference would be: pure shapes, pure compound shapes, convex shapes, compound convex shapes, and finally random shapes. Make sure to also read\xa0 this page . In case of the robot we want to build, we will make the base of the robot as a pure cylinder, and the other links as convex or convex decomposed shapes. \n \xa0 \n 因此，偏好的順序是：純形狀、純複合形狀、凸形、複合凸形狀，最後是隨機形狀。請務必也閱讀 此頁面 。在我們想要構建的機器人的情況下，我們將機器人的底座作為一個純圓柱體，其他連結作為凸或凸分解的形狀。 \n \xa0 \n We could use the dynamically enabled shapes also as the visible parts of the robot, but that would probably not look good enough. So instead, we will build for each visible shape we have created in\xa0 the first part of the tutorial \xa0a dynamically enabled counterpart, which we will keep hidden: the hidden part will represent the dynamic model and be exclusively used by the physics engine, while the visible part will be used for visualization, but also for\xa0 minimum distance calculations ,\xa0 proximity sensor detections , etc. \n \xa0 \n 我們可以將動態啟用的形狀用作機器人的可見部分，但可能看起來不夠好。因此，我們將為在 本教程的第一部分 中創建的每個可見形狀構建一個動態啟用的對應形狀，我們將隱藏該形狀：隱藏部分將表示動態模型，並由物理引擎獨佔使用，而可見部分將用於視覺化，但也用於 最小距離計算 、 接近感應器檢測 等。 \n We select object\xa0 robot , copy-and-paste it into a new scene (in order to keep the original model intact) and start the\xa0 triangle edit mode . If object\xa0 robot \xa0was a compound shape, we would first have had to ungroup it ([Menu bar --> Edit --> Grouping/Merging --> Ungroup selected shapes]) then merge the individual shapes ([Menu bar --> Edit --> Grouping/Merging --> Merge selected shapes]) before being able to start the triangle edit mode. Now we select the few triangles that represent the power cable, and erase them. Then we select all triangles in that shape, and click Extract cylinder. We can now leave the edit mode and we have our base object represented as a pure cylinder: \n \xa0 \n 我們選擇物件 機器人 ，複製並粘貼到一個新的場景（為了保持原始模型不變），並開始 三角形編輯模式 。如果物件 機器人 是複合形狀，我們首先必須取消群組它（[功能表列 -- > 編輯 --> 分組/合併 -- > 取消組選定形狀]），然後合併單個形狀（[功能表列 -- > 編輯 --> 分組/合併 -- > 合併所選形狀]），然後才能啟動三角形編輯模式。現在，我們選擇表示電源線的幾個三角形，並擦除它們。然後，我們選擇該形狀中的所有三角形，然後按一下"提取圓柱體"。我們現在可以離開編輯模式，並將基本物件表示為純圓柱體： \n We rename the new shape (with a double-click on its name in the\xa0 scene hierarchy ) as\xa0 robot_dyn , assign it to visibility layer 9, then copy it to the original scene. The rest of the links will be modelled as convex shapes, or compound convex shapes. We now select the first mobile link (i.e. object\xa0 robot_link1 ) and generate a convex shape from it with [Menu bar --> Add --> Convex hull of selection]. \n 我們將新形狀（在 場景層次結構 中按兩下其名稱）重命名為 robot_dyn， 將其分配給可見度層 9，然後將其複製到原始場景。其餘連結將建模為凸形或複合凸形。現在，我們選擇第一個手機連結（即物件 robot_link1）， 並生成一個凸形形狀，從它與 [功能表列 -- > 添加 -> 凸面選擇包]。 \n 40723242\xa0 \xa0 \xa0 \xa0 \xa0 趙子德 \n 40723243\xa0 \xa0 \xa0 \xa0 \xa0 劉子源 \n Model definition 型號定義 \n Now we are ready to define our model.  現在我們準備定義模型了。 \n We start by building the model herarchy: 我們從建立模型層次結構開始： \n we attach the last dynamic robot link (robot_link_dyn6) to its corresponding joint (robot_joint6) by selecting robot_link_dyn6, then control-selecting robot_joint6, then [Menu bar --> Edit --> Make last selected object parent]. 通過選擇robot_link_dyn6，然後控制選擇robot_joint6，然後選擇[菜單欄->編輯->創建最後一個選定的對象，將最後一個動態機器人鏈接（robot_link_dyn6）附加到其相應的關節（robot_joint6） \n We could also have done this step by simply dragging object robot_link_dyn6 onto robot_link6 in the scene hierarchy. 我們還可以通過簡單地將對象robot_link_dyn6拖到場景層次結構中的robot_link6上來完成此步驟。 \n We go on by now attaching robot_joint6 to robot_link_dyn5, and so on, until arrived at the base of the robot.  現在，我們將robot_joint6附加到robot_link_dyn5上，依此類推，直到到達機器人的底部。 \n We now have following scene hierarchy: 現在，我們具有以下場景層次結構： \n It is nice and more logical to have a simple name for the model base, since the model base will also represent the model itself. 為模型庫起一個簡單的名字是很好而且更合乎邏輯的，因為模型庫也將代表模型本身。 \n So we rename robot to robot_visibleBase, and robot_dyn to robot. 因此，我們將robot重命名為robot_visibleBase，並將robot_dyn重命名為robot。 \n Now we select the base of the hierarchy tree (i.e. object robot) and in the object common properties we enable Object is model base. We also enable Object/model can transfer or accept DNA. 現在我們選擇層次結構樹的基礎（即對像機械手），並在對象公共屬性中啟用``對像是模型基礎\'\'。我們還使對象/模型可以轉移或接受DNA。 \n A model bounding box appeared, encompassing the whole robot.  出現了一個模型包圍盒，包圍了整個機器人。 \n The bounding box however appears to be too large: this is because the bounding box also encompasses the invisible items, such as the joints. 但是，邊界框似乎太大：這是因為邊界框還包含不可見的項，例如關節。 \n We could do the same procedure for all invisible items in our model. 我們可以對模型中的所有不可見項執行相同的過程。 \n This is also a useful option in order to also exclude large sensors or other items from the model bounding box. We now have following situation: 這也是一個有用的選項，可以將大型傳感器或其他項目也排除在模型邊界框之外。我們現在有以下情況： \n We now protect our model from accidental modification.  現在，我們保護模型免受意外修改。 \n We select all visible objects in the robot, then enable Select base of model instead: if we now click a visible link in the scene, the base of the robot will be selected instead. 我們選擇機器人中的所有可見對象，然後啟用“選擇模型的基礎”：如果現在單擊場景中的可見鏈接，則會改為選擇機器人的基礎。 \n This allows us to manipulate the model as if it was a single object. We can still select visible objects in the robot via control-shift-clicking in the scene, or by selecting the object in the scene hierarchy.  這使我們可以像對待單個對像一樣操作模型。我們仍然可以通過按住Shift鍵並單擊場景或在場景層次中選擇對象來選擇機器人中的可見對象。 \n We now put the robot into a correct default position/orientation. First, we save current scene as a reference (e.g. if at a later stage we need to import CAD data that have the same orientation at the curent robot).  現在，我們將機器人置於正確的默認位置/方向。首先，我們將當前場景保存為參考（例如，如果稍後需要在當前機器人上導入方向相同的CAD數據）。 \n Then we select the model and modify its position/orientation appropriately. It is considered good practice to position the model (i.e. its base object) at X=0 and Y=0. 然後，我們選擇模型並適當修改其位置/方向。將模型（即其基礎對象）定位在X = 0和Y = 0處被認為是一種好習慣。 \n Then we select the model and modify its position/orientation appropriately. 然後，我們選擇模型並適當修改其位置/方向。 \n It is considered good practice to position the model (i.e. its base object) at X=0 and Y=0. 將模型（即其基礎對象）定位在X = 0和Y = 0處被認為是一種好習慣。 \n We now run the simulation: the robot will collapse, since the joints are not controlled by default. 現在我們運行模擬：由於默認情況下關節不受控制，因此機器人將崩潰。 \n When we added the joints in the previous stage, we created joints in force/torque mode, but their motor or controller was disabled (by default). 在上一階段添加關節時，我們以力/扭矩模式創建了關節，但其電動機或控制器已禁用（默認情況下）。 \n We can now adjust our joints to our requirements. In our case, we want a simple PID controller for each one of them. 現在，我們可以根據需要調整關節。在我們的案例中，我們希望為每個控制器都提供一個簡單的PID控制器。 \n In the joint dynamic properties, we click Motor enabled and adjust the maximum torque.  在關節動態屬性中，單擊“啟用電機”並調整最大扭矩。 \n We then click Control loop enabled and select Position control (PID). We now run the simulation again: the robot should hold its position.  然後，單擊啟用控制環，然後選擇位置控制（PID）。現在，我們再次運行仿真：機器人應保持其位置。 \n Try to switch the current physics engine to see if the behaviour is consistent across all supported physics engines.  嘗試切換當前的物理引擎，以查看行為在所有受支持的物理引擎之間是否一致。 \n You can do this via the appropriate toolbar button, or in the general dynamics properties. 您可以通過相應的工具欄按鈕或在常規動力學屬性中執行此操作。 \n During simulation, we now verify the scene dynamic content via the Dynamic content visualization & verification toolbar button. 在仿真過程中，我們現在通過“動態內容可視化和驗證”工具欄按鈕來驗證場景動態內容。 \n Now, only items that are taken into account by the physics engine will be display, and the display is color-coded.  現在，將僅顯示物理引擎考慮的項目，並且該顯示使用顏色編碼。 \n \n 40723245\xa0 \xa0 \xa0 \xa0 \xa0 蔡育灃 \n It is very important to always do this, and specially when your dynamic model doesn\'t behave as expected, in order to quickly debug the model. Similarly, always look at the scene hierarchy during simulation: dynamically enabled objects should display a ball-bounding icon on the right-hand side of their name. \n 始終執行此操作非常重要，尤其是在動態模型無法按預期運行時，為了快速調試模型，尤其如此。同樣，在仿真過程中請始終查看場景層次：動態啟用的對象應在其名稱的右側顯示一個球形圖標。 \n Finally, we need to prepare the robot so that we can easily attach a gripper to it, or easily attach the robot to a mobile platform (for instance). Two dynamically enabled shapes can be rigidly attached to each other in two different ways: \n 最後，我們需要準備機器人，以便我們可以輕鬆地將抓取器連接到它，或輕鬆地將機器人連接到移動平台（例如）。可以通過兩種不同的方式將兩個動態啟用的形狀嚴格地彼此附加： \n • by grouping them: select the shapes, then [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]. • by attaching them via a force/torque sensor: a force torque sensor can also act as a rigid link between two separate dynamically enabled shapes. \n •通過對它們進行分組：選擇形狀，然後選擇[菜單欄->編輯->分組/合併->對選定形狀進行分組]。 •通過力/扭矩傳感器進行連接：力扭矩傳感器還可以充當兩個單獨的動態啟用形狀之間的剛性鏈接。 \n In our case, only option 2 is of interest. We create a force/torque sensor with [Menu bar --> Add --> Force sensor], then move it to the tip of the robot, then attach it to object robot_link_dyn6. We change its size and visual appearance appropriately (a red force/torque sensor is often perceived as an optional attachment point, check the various robot models available). We also change its name to robot_attachment: \n 在我們的情況下，只有選項2是有意義的。我們使用[菜單欄->添加->力傳感器]創建一個力/扭矩傳感器，然後將其移動到機器人的尖端，然後將其附加到對象robot_link_dyn6。我們會適當地更改其尺寸和外觀（紅色力/扭矩傳感器通常被視為可選的連接點，請檢查可用的各種機器人型號）。我們還將其名稱更改為robot_attachment： \n Now we drag a gripper model into the scene, keep it selected, then control-click the attachment force sensor, then click the Assembling/disassembling toolbar button. The gripper goes into place: \n 現在，我們將抓手模型拖到場景中，使其保持選中狀態，然後按住Control鍵單擊並單擊附著力傳感器，然後單擊“裝配/拆卸”工具欄按鈕。夾持器到位： \n The gripper knew how to attach itself because it was appropriately configured during its model definition. We now also need to properly configure the robot model, so that it will know how to attach itself to a mobile base for instance. We select the robot model, then click Assembling in the object common properties. Set an empty string for \'Parent\' match values, then click Set matrix. This will memorize the current base object\'s local transformation matrix, and use it to position/orient itself relative to the mobile robot\'s attachment point. To verify that we did things right, we drag the model Models/robots/mobile/KUKA Omnirob.ttm into the scene. Then we select our robot model, then control-click one of the attachment points on the mobile platform, then click the Assembling/disassembling toolbar button. Our robot should correctly place itself on top of the mobile robot: \n 抓具知道如何附加自身，因為它在模型定義期間進行了適當的配置。現在，我們還需要正確配置機器人模型，以便它將知道如何將自己附加到移動基座上。我們選擇機器人模型，然後在對象公共屬性中單擊“組裝”。為“父項”匹配值設置一個空字符串，然後單擊“設置矩陣”。這將記住當前基礎對象的局部轉換矩陣，並使用它相對於移動機器人的附著點定位/定向。為了驗證我們做的正確，我們將模型Models / robots / mobile / KUKA Omnirob.ttm拖到場景中。然後，我們選擇機器人模型，然後在移動平台上按住Control鍵並單擊其中一個附接點，然後單擊“組裝/拆卸”工具欄按鈕。我們的機器人應該正確地將自己放置在移動機器人的頂部： \n Now we could add additional items to our robot, such as sensors for instance. At some point we might also want to attach embedded scripts to our model, in order to control its behaviour or configure it for various purposes. In that case, make sure to understand how object handles are accessed from embedded scripts. We can also control/access/interface our model from a plugin, from a remote API client, from a ROS node, from a BlueZero node, or from an add-on. Now we make sure we have reverted the changes done during robot and gripper attachment, we collapse the hierarchy tree of our robot model, select the base of our model, then save it with [Menu bar --> File --> Save model as...]. If we saved it in the model folder, then the model will be available in the model brower. \n 現在，我們可以向機器人添加其他項目，例如傳感器。在某些時候，我們可能還希望將嵌入式腳本附加到我們的模型中，以便控制其行為或出於各種目的對其進行配置。在這種情況下，請確保了解如何從嵌入式腳本訪問對象句柄。我們還可以通過插件，遠程API客戶端，ROS節點，BlueZero節點或附加組件來控制/訪問/接口模型。 現在，確保已恢復在機械手和抓爪安裝過程中所做的更改，我們折疊了機械手模型的層次樹，選擇了模型的基礎，然後使用[菜單欄->文件->將模型另存為...]。如果我們將其保存在模型文件夾中，則模型將在模型瀏覽器中可用。 \n Webots User Guide \n 40723201\xa0 \xa0 \xa0 \xa0 \xa0 吳沛汶 \n 40723204\xa0 \xa0 \xa0 \xa0 \xa0 邱倚瀅 \n Modifying the Floor \n 修改地板\xa0 \n The default\xa0RectangleArena\xa0PROTO defines a simple floor pinned on the static environment, i.e. without\xa0 Physics \xa0node, and surrounded by walls. Other pre-built floors are available in the Webots objects library. We will now delete the\xa0RectangleArena\xa0node and add a simple floor that we will manually surround with walls later in this tutorial. \n 默認的RectangleArena PROTO定義了一個固定在靜態環境上的簡單地板，即沒有Physics節點並且被牆壁包圍。 Webots對像庫中提供了其他預建樓層。現在，我們將刪除RectangleArena節點，並添加一個簡單的地板，在本教程的後面部分將用牆手動將其包圍。 \n Hands-on 2 : To remove the\xa0RectangleArena, select it either in the 3D view or in the scene tree view with a left click and press the\xa0Delete\xa0key on your keyboard. Alternatively, you can right click on it in the 3D view and select\xa0Delete\xa0in the context menu (you can also use the context menu directly in the scene tree view). Select the\xa0TexturedBackroundLight\xa0node and click on the\xa0Add\xa0button. In the open dialog box, and choose\xa0PROTO nodes (Webots Projects) / objects / floors / Floor (Solid) \n 動手操作2：要刪除RectangleArena，請在3D視圖或場景樹視圖中單擊鼠標左鍵將其選中，然後按鍵盤上的Delete鍵。或者，可以在3D視圖中右鍵單擊它，然後在上下文菜單中選擇“刪除”（也可以直接在場景樹視圖中使用上下文菜單）。選擇TexturedBackroundLight節點，然後單擊“添加”按鈕。在打開的對話框中，然後選擇PROTO節點（Webots項目）/對象/ Floors / Floor（實心） \n \xa0The newly added\xa0Floor\xa0PROTO has a default size of 10mx10m, but it is possible to adjust its size, its position and texture by changing the corresponding fields. \n 新添加的Floor PROTO的默認大小為10mx10m，但是可以通過更改相應的字段來調整其大小，位置和紋理。 \n Hands-on 3 : In the scene tree view select and expand the\xa0Floor. Modify the\xa0size\xa0field and set it to\xa0{1, 1}\xa0to resize it to 1mx1m. \n 動手＃3：在場景樹視圖中，選擇並展開“地板”。修改大小字段並將其設置為{1，1}以將其大小調整為1m x 1m。 \n \xa0The Solid Node \n 實體節點 \n This subsection introduces the most important base node in Webots: the\xa0 Solid \xa0node, from which many other nodes derive. \n 本小節介紹了Webots中最重要的基礎節點：Solid節點，許多其他節點都來自Solid節點。 \n \n 40723213\xa0 \xa0 \xa0 \xa0 \xa0 杜玗宸 \n 翻譯Webots User Guide \n A\xa0 Solid \xa0node represents a\xa0 rigid body , that is a body in which deformation can be neglected. The distance between any two given points of a rigid body remains constant in time regardless of external forces exerted on it. For example a table, a robot finger phalanx or a wheel are rigid bodies. Soft bodies and articulated objects are not rigid bodies. For example, a rope, a tire, a sponge or an articulated robot arm are not rigid bodies. However, an articulated entity can be broken into several rigid bodies. \n The physics engine of Webots is designed for simulating rigid bodies only. An important step, when designing a simulation, is to break up the various entities into separate rigid bodies. \n To define a rigid body, you will have to create a\xa0 Solid \xa0node. Inside this node you will set up different sub-nodes corresponding to the characteristics of the rigid body. The following\xa0 figure \xa0depicts a rigid body and its sub-nodes. The graphical representation of the\xa0 Solid \xa0node is defined by the\xa0 Shape \xa0nodes populating its\xa0children\xa0list. The collision bounds are defined in its\xa0boundingObject\xa0field. The graphical representation and the collision shape are often but not necessarily identical. Finally, the\xa0physics\xa0field defines if the object belongs to the dynamical or to the static environment. All these sub-nodes are optional, but the\xa0physics\xa0field needs the\xa0boundingObject\xa0to be defined. \n \n The simplest model of a rigid body in Webots having a graphical representation, a physical bounding object and being in the dynamical environment. \n The Geometry box (in\xa0 this figure ) stands for any kind of geometrical primitive. In fact, it can be substituted by a\xa0 Sphere , a\xa0 Box , a\xa0 Cylinder , etc. \n 實體節點表示剛體，即可以忽略變形的剛體。剛體上任意兩個給定點之間的距離在時間上保持恆定，而不管施加在其上的外力如何。例如，桌子，機械手指骨或輪子是剛體。軟體和關節物體不是剛體。例如，繩索，輪胎，海綿或關節式機械臂不是剛性體。但是，可以將一個鉸接的實體分解為幾個剛體。 \n Webots 的物理引擎僅設計用於模擬剛體。設計仿真時，重要的一步是將各個實體分解為單獨的剛體。 \n 要定義剛體，您將必須創建一個實體節點。在此節點內，您將根據剛體的特性設置不同的子節點。下圖描繪了剛體及其子節點。實體節點的圖形表示由填充其子級列表的 Shape 節點定義。碰撞範圍在其 boundingObject 字段中定義。圖形表示和碰撞形狀通常但不一定相同。最後，物理字段定義對像是屬於動態環境還是屬於靜態環境。所有這些子節點都是可選的，但物理場需要定義 boundingObject 。 \n \n Webots 中剛體的最簡單模型，具有圖形表示，物理邊界對象並且處於動態環境中。 \n 幾何框（在此圖中）代表任何類型的幾何圖元。 實際上，它可以用球體，盒子，圓柱體等代替。 \n 40723215\xa0 \xa0 \xa0 \xa0 \xa0 杜彥霆 \n 40723218\xa0 \xa0 \xa0 \xa0 \xa0 林志豪 \n A\xa0 Solid \xa0node represents a\xa0 rigid body , that is a body in which deformation can be neglected. The distance between any two given points of a rigid body remains constant in time regardless of external forces exerted on it. For example a table, a robot finger phalanx or a wheel are rigid bodies. Soft bodies and articulated objects are not rigid bodies. For example, a rope, a tire, a sponge or an articulated robot arm are not rigid bodies. However, an articulated entity can be broken into several rigid bodies. \n The physics engine of Webots is designed for simulating rigid bodies only. An important step, when designing a simulation, is to break up the various entities into separate rigid bodies. \n To define a rigid body, you will have to create a\xa0 Solid \xa0node. Inside this node you will set up different sub-nodes corresponding to the characteristics of the rigid body. The following\xa0 figure \xa0depicts a rigid body and its sub-nodes. The graphical representation of the\xa0 Solid \xa0node is defined by the\xa0 Shape \xa0nodes populating its\xa0 children \xa0list. The collision bounds are defined in its\xa0 boundingObject \xa0field. The graphical representation and the collision shape are often but not necessarily identical. Finally, the\xa0 physics \xa0field defines if the object belongs to the dynamical or to the static environment. All these sub-nodes are optional, but the\xa0 physics \xa0field needs the\xa0 boundingObject \xa0to be defined. \n 實體節點表示剛體，即可以忽略變形的剛體。剛體上任意兩個給定點之間的距離在時間上保持恆定，而不管施加在其上的外力如何。例如，桌子，機械手指骨或輪子是剛體。軟體和關節物體不是剛體。例如，繩索，輪胎，海綿或關節式機械臂不是剛性體。但是，可以將一個鉸接的實體分解為幾個剛體。 \n Webots的物理引擎僅設計用於模擬剛體。設計仿真時，重要的一步是將各個實體分解為單獨的剛體。 \n 要定義剛體，您將必須創建一個實體節點。在此節點內，您將根據剛體的特性設置不同的子節點。下圖描繪了剛體及其子節點。實體節點的圖形表示由填充其子級列表的Shape節點定義。碰撞範圍在其boundingObject字段中定義。圖形表示和碰撞形狀通常但不一定相同。最後，物理字段定義對像是屬於動態環境還是屬於靜態環境。所有這些子節點都是可選的，但物理場需要定義boundingObject。 \n \n The simplest model of a rigid body in Webots having a graphical representation, a physical bounding object and being in the dynamical environment. \n Webots中剛體的最簡單模型，具有圖形表示，物理邊界對象並且處於動態環境中。 \n The Geometry box (in\xa0 this figure ) stands for any kind of geometrical primitive. In fact, it can be substituted by a\xa0 Sphere , a\xa0 Box , a\xa0 Cylinder , etc. \n 幾何框（在此圖中）代表任何類型的幾何圖元。 實際上，它可以用球體，盒子，圓柱體等代替。 \n 40723219\xa0 \xa0 \xa0 \xa0 \xa0 林承治 \n 40723237\xa0 \xa0 \xa0 \xa0 \xa0 黃俊翔 \n', 'tags': '', 'url': 'week17協同任務.html'}, {'title': 'DEF-USE Mechanism', 'text': '', 'tags': '', 'url': 'DEF-USE Mechanism.html'}, {'title': 'DEF-USE 機制', 'text': 'The\xa0 DEF-USE mechanism \xa0allows to define a node in one place and to reuse that definition elsewhere in the scene tree. This is useful to avoid the duplication of identical nodes in world files. Moreover, it also allows users to modify several objects at the same time. Here is how it works: first a node is labeled with a DEF string. Then copies of this node can be reused elsewhere with the USE keyword. Only the fields of the DEF node can be edited, the fields of the USE inherit from the DEF node and cannot be changed. This mechanism is dependent on the order of the nodes in the world file. A DEF node should be defined before any corresponding USE node. \n \xa0 \n DEF-USE  機制 允許在一個位置定義節點，並在場景樹的其他位置重用該定義。這對於避免世界檔中相同節點的重複非常有用。此外，它還允許使用者同時修改多個物件。下面是它的工作原理：首先，節點用  DEF  字串標記。然後，此節點的副本可以使用  USE  關鍵字在其他地方重用。只能編輯  DEF  節點的欄位， USE  的欄位從  DEF  節點繼承，不能更改。此機制取決於世界檔中節點的順序。應在任何相應的  USE  節點之前定義  DEF  節點。 \n The two\xa0 Sphere \xa0definitions that we have used earlier to define the ball, are redundant. We will now merge these two\xa0 Spheres \xa0into only once using the DEF-USE mechanism. \n \xa0 \n \xa0 我們之前用於定義球的兩個球體定義是多餘的。現在，我們將使用  DEF-USE  機制僅將這兩個 球體 合併為一次。 \n Hands-on #6 : Select the first\xa0 Sphere \xa0node (the child of the\xa0 Shape ) in the scene tree view. The\xa0 field editor \xa0of the scene tree view allows you to enter the DEF string. \n \xa0 \n 動手 #6：在場景樹狀檢視中選擇第一個 球體 節點（ 形狀 子節點）。  \xa0 場景樹狀檢視的欄位編輯器允許您輸入  DEF  字串。 \n \n Enter\xa0BALL_GEOMETRYin this field. \n 在此欄位中輸入BALL_GEOMETRY。 \n Select the\xa0boundingObjectfield (containing the second\xa0 Sphere \xa0node), and empty it by right clicking the field in the scene tree and choosing the\xa0Delete\xa0entry in the context menu that pops up. \n 選擇邊界物件欄位（包含第二個  Sphere  節點），然後通過按右鍵場景樹中的欄位並在彈出的內容功能表中選擇"刪除"條目來清空該欄位。 \n Then, select the\xa0boundingObjectfield and click on the\xa0Add\xa0button, and select the\xa0USE / BALL_GEOMETRY\xa0in the dialog box. \n 然後，選擇"邊界物件 " 欄位並按一下"添加 " 按鈕，然後在對話方塊中選擇"使用 /BALL_GEOMETRY" 。 \n The result is shown in\xa0 this figure . \n 結果如下 圖 所示。 \n \n 40723242\xa0 \xa0 \xa0 \xa0 \xa0 趙子德 \n 40723243\xa0 \xa0 \xa0 \xa0 \xa0 劉子源 \n Now, changing the radius field of the first Sphere node also modifies its boundingObject. 現在，更改第一個Sphere節點的半徑字段也會修改其boundingObject。 \n For convenience, the boundingObject field accepts also the Shape node (rather than the Sphere node directly). It would be also possible to use the same DEF-USE mechanism at the Shape level as shown in this figure. 為了方便起見，boundingObject字段還接受Shape節點（而不是直接接受Sphere節點）。如圖所示，也可以在Shape級別使用相同的DEF-USE機制。 \n For now the greatest benefit is being able to also use this Shape directly for graphical purposes. Later this mechanism will turn out to be very useful for some sensors. 到目前為止，最大的好處就是也可以直接將此Shape用於圖形目的。後來，對於某些傳感器，該機制將變得非常有用。 \n on the Sphere node called BALL_GEOMETRY. 在名為BALL_GEOMETRY的Sphere節點上。 \n physics 物理 boundingObject children 孩子們 geometry 幾何 Solid 固體 Physics 物理 USE BALL_GEOMETRY 使用BALL_GEOMETRY Shape 形狀 DEF BALL_GEOMETRY Sphere DEF BALL_GEOMETRY球體 \n DEF-USE mechanism applied on the Shape node of a Solid. Hands-on #7: Create a second ball with the same parameters but using the Shape node (rather than the Sphere node directly) for the DEF-USE mechanism. \n 在實體的“形狀”節點上應用的DEF-USE機制。 動手練習7：使用DEF-USE機制的Shape節點（而不是直接使用Sphere節點）創建具有相同參數的第二個球。 \n 40723245\xa0 \xa0 \xa0 \xa0 \xa0 蔡育灃 \n Add Walls In order to verify your progression, implement by yourself four walls to surround the environment. The walls have to be defined statically to the environment. To understand the difference between static and dynamic, let\'s take a defined object (the ball) above the ground. If the Physics node is NULL, it will remain frozen in the air during the simulation (static case). If the physics field contains a Physics nodes, it will fall under the effect of gravity (dynamic case). \n 添加牆 為了驗證您的進度，請自己實施四堵牆以包圍環境。必鬚根據環境靜態定義牆壁。要了解靜態和動態之間的區別，我們將定義的物體（球）放在地面上方。如果“物理”節點為NULL，則在仿真過程中它將保持凍結狀態（靜態情況）。如果物理場包含“物理”節點，則它將受重力作用（動態情況）。 \n Use as much as possible the DEF-USE mechanism at the Shape level rather than at the Geometry level. Indeed it\'s more convenient to add an intermediate Shape node in the boundingObject field of the Solid node. The best Geometry primitive to implement the walls is the Box node. Only one Shape has to be defined for all the walls. The expected result is shown in this figure. \n 在Shape級別而不是Geometry級別，盡可能使用DEF-USE機制。實際上，在Solid節點的boundingObject字段中添加中間Shape節點更為方便。實現牆的最佳幾何原語是Box節點。所有牆壁僅需定義一個形狀。預期結果如圖所示 \n Hands-on #8: Add four walls without physics and using only one definition of the Shape node. \n 實際操作＃8：添加四面牆，無需物理操作，僅使用“形狀”節點的一個定義。 \n Solution: World File To compare your world with the solution, go to your files and find the folder named "my_first_simulation" created in Tutorial 1, then go to the "worlds" folder and open with a text editor the right world. This solution as the others is located in the solution directory. \n 解決方案：世界文件 要將您的世界與解決方案進行比較，請轉到文件，找到在教程1中創建的名為“ my_first_simulation”的文件夾，然後轉到“ worlds”文件夾，並使用文本編輯器打開正確的世界。與其他解決方案一樣，該解決方案位於解決方案目錄中。 \n', 'tags': '', 'url': 'DEF-USE 機制.html'}, {'title': 'M.A.L', 'text': '\n \xa0☑出席\xa0 \xa0 \xa0 ☒缺席 \n \n \n \n \xa0member/week\xa0 \n \xa0week10\xa0 \n \xa0week12\xa0 \n \xa0week13\xa0 \n \xa0week14\xa0 \n \xa0week15\xa0 \n \xa0week16\xa0 \n \xa0week17\xa0 \n \xa0week18\xa0 \n \n \n 吳沛汶 \n ✔ \n ✔ \n ✔ \n \n \n \n \n \n \n \n 邱倚瀅 \n ✔ \n ✔ \n ✔ \n \n \n \n \n \n \n \n 杜玗宸 \n ✔ \n ✔ \n ✔ \n \n \n \n \n \n \n \n 杜彥霆 \n ✘ \n ✘ \n ✘ \n \n \n \n \n \n \n \n 林志豪 \n ✘ \n ✔ \n ✔ \n \n \n \n \n \n \n \n 林承治 \n ✔ \n ✔ \n ✔ \n \n \n \n \n \n \n \n 黃俊翔 \n ✔ \n ✔ \n ✔ \n \n \n \n \n \n \n \n 趙子德 \n ✔ \n ✔ \n ✔ \n \n \n \n \n \n \n \n 劉子源\xa0\xa0 \n ✔ \n ✔ \n ✔ \n \n \n \n \n \n \n \n 蔡育灃 \xa0 \n ✔ \n ✔ \n ✔ \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'M.A.L.html'}, {'title': 'NOTE', 'text': '', 'tags': '', 'url': 'NOTE.html'}, {'title': 'website', 'text': 'issues \n 2019 Fall 電腦輔助設計實習課程網頁 \n \n', 'tags': '', 'url': 'website.html'}, {'title': 'Batch Command', 'text': '1.cad.bat - 啟動 wsgi.py 並且在瀏覽器開啟 https 9443 動態網頁. \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n \n \n \n @echo off \n y: \n cd tmp\\cad2019\\cmsimde \n start python wsgi.py | start chrome https: //localhost:9443 \n \n \n \n \n \n 2.cadh.bat - 啟動 \xa0 http-server \xa0 並且在瀏覽氣開啟 \xa0 https 8444 \xa0 靜態網頁 . \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n \n \n \n @echo off \n y: \n cd tmp\\cad2019\\ \n start python http-server.py | start chrome https: //localhost:8444 \n \n \n \n \n \n \n \n \n \n 3.cadg.bat-近端倉儲維護告一段落後 , \xa0 啟動 \xa0 gitextensions \xa0 開啟 \xa0 cad2019 \xa0 倉儲時 , \xa0 使用 . \n \n \n \n \n 1 \n 2 \n 3 \n \n \n \n @echo off \n y: \n Y:\\cad\\201906_fall\\data\\GitExtensions\\gitextensions.exe\xa0 browse y:\\tmp\\cad2019\\ \n \n \n \n \n \n [~ 複製貼上更改檔案位置即可 , 有時啟動需間隔一些時間 ~] \n \n \n \n \xa0', 'tags': '', 'url': 'Batch Command.html'}]};